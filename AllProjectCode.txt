//
//  ContentView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//


import SwiftUI
import Swinject

struct DemoView: View {
    @State private var query = ""
    @Environment(\.resolver) private var resolver
    var body: some View {
        NavigationStack {
            Text("Boot OK")
            Text("Resolver hash: \(ObjectIdentifier(resolver as AnyObject).hashValue)")

                .font(.caption)
                .foregroundStyle(.secondary)
            VStack(spacing: Tokens.Spacing.x24) {
                SearchField("Partner's name...", text: $query)

                PrimaryButton("Find", isDisabled: query.isEmpty) {
                    // позже добавим действие
                }

                Spacer()
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.top, Tokens.Spacing.x24)
            .background(Tokens.Color.backgroundMain.ignoresSafeArea())
            .navigationTitle("CheaterBuster")
        }
    }
}

//
//  PrimaryButton.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//

import SwiftUI

public struct PrimaryButton: View {
    public enum Size { case large, medium }

    let title: String
    let size: Size
    let isLoading: Bool
    let isDisabled: Bool
    let action: () -> Void

    public init(_ title: String,
                size: Size = .large,
                isLoading: Bool = false,
                isDisabled: Bool = false,
                action: @escaping () -> Void) {
        self.title = title
        self.size = size
        self.isLoading = isLoading
        self.isDisabled = isDisabled
        self.action = action
    }

    public var body: some View {
        Button(action: action) {
            ZStack {
                if isLoading {
                    ProgressView().tint(.white)
                } else {
                    Text(title)
                        .font(Tokens.Font.subtitle)
                        .foregroundColor(.white)
                        .lineLimit(1)
                }
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, size == .large ? 16 : 12)
            // iOS-style corner smoothing (.continuous)
            .background(
                (isDisabled ? Tokens.Color.accentPressed : Tokens.Color.accent),
                in: RoundedRectangle(cornerRadius: Tokens.Radius.pill, style: .continuous)
            )
        }
        .buttonStyle(.plain)
        .disabled(isDisabled || isLoading)
        .accessibilityAddTraits(.isButton)
    }
}
//
//  SearchField.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//

import SwiftUI

public struct SearchField: View {
    @Binding var text: String
    var placeholder: String
    var onCommit: (() -> Void)?
    var onCancel: (() -> Void)?

    @FocusState private var focused: Bool

    public init(_ placeholder: String,
                text: Binding<String>,
                onCommit: (() -> Void)? = nil,
                onCancel: (() -> Void)? = nil) {
        self.placeholder = placeholder
        self._text = text
        self.onCommit = onCommit
        self.onCancel = onCancel
    }

    public var body: some View {
        HStack(spacing: Tokens.Spacing.x12) {
            HStack(spacing: Tokens.Spacing.x12) {
                Image(systemName: "magnifyingglass")
                    .foregroundColor(Tokens.Color.textSecondary)

                TextField(placeholder, text: $text)
                    .font(Tokens.Font.body)
                    .foregroundColor(Tokens.Color.textPrimary)
                    .focused($focused)
                    .submitLabel(.search)
                    .onSubmit { onCommit?() }

                if !text.isEmpty {
                    Button {
                        text = ""
                    } label: {
                        Image(systemName: "xmark")
                            .foregroundColor(Tokens.Color.textSecondary)
                    }
                    .accessibilityLabel("Clear text")
                }
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.vertical, 12)
            .background(
                Tokens.Color.surfaceCard,
                in: RoundedRectangle(cornerRadius: Tokens.Radius.pill, style: .continuous)
            )
            .overlay(
                RoundedRectangle(cornerRadius: Tokens.Radius.pill, style: .continuous)
                    .stroke(Tokens.Color.borderNeutral, lineWidth: 1)
            )
            .apply(Tokens.Shadow.card)

            if focused {
                Button("Cancel") {
                    text = ""
                    focused = false
                    onCancel?()
                }
                .font(Tokens.Font.body)
                .foregroundColor(Tokens.Color.textSecondary)
                .transition(.opacity.combined(with: .move(edge: .trailing)))
            }
        }
        .animation(.easeOut(duration: 0.25), value: focused)
    }
}
//
//  DesignTokens.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//

import SwiftUI

public enum Tokens {
    
    // MARK: Colors (Figma -> SwiftUI)
    public enum Color {
        public static let accent = SwiftUI.Color("Accent")
        public static let accentPressed = SwiftUI.Color("AccentPressed")
        
        public static let textPrimary = SwiftUI.Color("TextPrimary")
        public static let textSecondary = SwiftUI.Color("TextSecondary")
        
        public static let borderNeutral = SwiftUI.Color("BorderNeutral")
        
        public static let backgroundMain = SwiftUI.Color("BackgroundMain")
        public static let surfaceCard = SwiftUI.Color("SurfaceCard")
    }
    
    //MARK: Typography (SF Pro)
    public enum Font {
        public static let h1 = SwiftUI.Font.system(size:32, weight: .semibold)
        public static let h2 = SwiftUI.Font.system(size:28, weight: .medium)
        public static let title = SwiftUI.Font.system(size:22, weight: .medium)
        public static let subtitle = SwiftUI.Font.system(size:20, weight: .bold)
        public static let body = SwiftUI.Font.system(size:20, weight: .regular)
        public static let bodyMedium18 = SwiftUI.Font.system(size:18, weight: .medium)
        static let bodyMedium = SwiftUI.Font.system(size: 16, weight: .medium)
        public static let caption = SwiftUI.Font.system(size: 15, weight: .medium)
        public static let captionRegular = SwiftUI.Font.system(size: 15, weight: .regular)
    }
    
    //MARK: Spacing & Radius
    
    public enum Spacing {
        public static let x4:  CGFloat = 4
        public static let x8:  CGFloat = 8
        public static let x12: CGFloat = 12
        public static let x16: CGFloat = 16
        public static let x20: CGFloat = 20
        public static let x24: CGFloat = 24
        public static let x32: CGFloat = 32
    }
    
    public enum Radius {
        public static let pill:   CGFloat = 24
        public static let medium: CGFloat = 16
        public static let small:  CGFloat = 12
    }
    
    // MARK: Shadow
    public enum Shadow {
        public static let card = ShadowStyle(
            color: .black.opacity(0.07),
            radius: 12,
            y: 6
        )
    }
    
}

// MARK: Helpers
public struct ShadowStyle {
    public let color: Color
    public let radius: CGFloat
    public let y: CGFloat
}

public extension View {
    func apply(_ shadow: ShadowStyle) -> some View {
        self.shadow(color: shadow.color, radius: shadow.radius, x: 0, y: shadow.y)
    }
}
//
//  Corner+Helpers.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import SwiftUI

public extension View {
    @inlinable
    func cornerRadiusContinuous(_ r: CGFloat) -> some View {
        clipShape(RoundedRectangle(cornerRadius: r, style: .continuous))
    }

    @inlinable
    func roundedBorder(_ color: Color, lineWidth: CGFloat, radius: CGFloat) -> some View {
        overlay(
            RoundedRectangle(cornerRadius: radius, style: .continuous)
                .stroke(color, lineWidth: lineWidth)
        )
    }
}
//
//  Environment+Resolver.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import SwiftUI
import Swinject

private struct ResolverKey: EnvironmentKey {
    static let defaultValue: Resolver = Assembler([]).resolver
}

extension EnvironmentValues {
    var resolver: Resolver {
        get { self[ResolverKey.self]}
        set { self[ResolverKey.self] = newValue }
    }
}
//
//  DevSeed.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import Foundation
import Swinject

enum DevSeed {
    static func run(_ resolver: Resolver) {
        #if DEBUG
        guard let store = resolver.resolve(CheaterStore.self) else { return }

        // Чтобы не дублировать при каждом запуске — только если история пустая
        if store.load().isEmpty {
            store.add(.init(kind: .image, riskScore: 80, note: "WhatsApp screenshot"))
            store.add(.init(kind: .file,  riskScore: 92, note: "PDF contract"))
        }
        #endif
    }
}
//
//  AppAssembler.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Swinject

enum AppAssembler {
    static func make() -> Assembler {
        Assembler([
            ServicesAssembly(),
            ViewModelsAssembly()
        ])
    }
}
//
//  ServicesAssemble.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Swinject

final class ServicesAssembly: Assembly {
    func assemble(container: Container) {
        container.register(SearchService.self) { _ in
                SearchServiceImpl()
        }.inObjectScope(.container)
        
        container.register(CheaterAnalyzerService.self) { _ in
            CheaterAnalyzerServiceImpl()
        }.inObjectScope(.container)
     
        container.register(HistoryStore.self) { _ in
            HistoryStoreImpl()
        }.inObjectScope(.container)
        
        container.register(CheaterStore.self) { _ in CheaterStoreImpl() }
        
        container.register(SettingsStore.self) { _ in SettingsStoreImpl() }
                   .inObjectScope(.container)
    }
}
//
//  CheaterBusterApp.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//

import SwiftUI
import Swinject

@main
struct CheaterBusterApp: App {
    
    private let assembler = AppAssembler.make() 
    private var resolver: Resolver { assembler.resolver }

    var body: some Scene {
        WindowGroup {
            RootTabView()
                .environment(\.resolver, resolver)

                .task {
                    DevSeed.run(resolver)
                }
        }
    }
}
//
//  RootTabView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import SwiftUI
import Swinject

struct RootTabView: View {
    @Environment(\.resolver) private var resolver

    var body: some View {
        TabView {
            
            SearchScreen(vm: resolver.resolve(SearchViewModel.self)!)
                .tabItem { Label("Search", systemImage: "magnifyingglass") }

            CheaterScreen()  // временно без VM
                .tabItem { Label("Cheater", systemImage: "person.crop.circle.badge.exclamationmark") }

            HistoryView(vm: resolver.resolve(HistoryViewModel.self)!)

            SettingsScreen()
                .tabItem { Label("Settings", systemImage: "gearshape") }
        }
    }
}
//
//  ViewModelsAssembly.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Swinject

final class ViewModelsAssembly: Assembly {
    func assemble(container: Container) {
        container.register(SearchViewModel.self) { r in
            SearchViewModel(search: r.resolve(SearchService.self)!,
                            history: r.resolve(HistoryStore.self)!,
                            settings: r.resolve(SettingsStore.self)!)
        }
        container.register(CheaterViewModel.self) { r in
            CheaterViewModel(analyzer: r.resolve(CheaterAnalyzerService.self)!)
        }
      
        container.register(HistoryViewModel.self) { r in
            HistoryViewModel(
                store: r.resolve(HistoryStore.self)!,
                cheaterStore: r.resolve(CheaterStore.self)!,
                search: r.resolve(SearchService.self)!
            )
        }
        
        container.register(SettingsViewModel.self) { r in
            SettingsViewModel(store: r.resolve(SettingsStore.self)!)
        }
    }
}
//
//  SettingsStoreImpl.swift
//  CheaterBuster
//

import Foundation

final class SettingsStoreImpl: SettingsStore {
    private let key = "isHistoryEnabled"

    // Хотим дефолт = true. bool(forKey:) даёт false, если ключ не записан.
    // Поэтому, если ключа нет — возвращаем true.
    var isHistoryEnabled: Bool {
        get {
            let defaults = UserDefaults.standard
            if defaults.object(forKey: key) == nil {
                return true
            }
            return defaults.bool(forKey: key)
        }
        set {
            UserDefaults.standard.set(newValue, forKey: key)
        }
    }
}
//
//  HistoryStoreImpl.swift
//  CheaterBuster
//

import Foundation
import UIKit

final class HistoryStoreImpl: HistoryStore {
    private let key = "cb.history.v1"
    private let limit = 10
    private let defaults: UserDefaults

    init(defaults: UserDefaults = .standard) {
        self.defaults = defaults
    }

    func load() -> [HistoryRecord] {
        guard let data = defaults.data(forKey: key) else { return [] }
        return (try? JSONDecoder().decode([HistoryRecord].self, from: data)) ?? []
    }

    func add(_ record: HistoryRecord) {
        var arr = load()

        // глобальная де-дупликация:
        if let q = record.query {
            arr.removeAll { $0.kind == .name && $0.query == q }
        } else if let data = record.imageJPEG {
            let h = data.hashValue
            arr.removeAll { $0.kind == .face && ($0.imageJPEG?.hashValue == h) }
        }

        arr.insert(record, at: 0)
        if arr.count > limit {
            arr = Array(arr.prefix(limit))
        }
        save(arr)
    }

    func clearAll() {
        defaults.removeObject(forKey: key)
    }

    private func save(_ arr: [HistoryRecord]) {
        if let data = try? JSONEncoder().encode(arr) {
            defaults.set(data, forKey: key)
        }
    }
}
//
//  CheaterAnalyzerServiceImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import Combine

final class CheaterAnalyzerServiceImpl: CheaterAnalyzerService {
    func analyze(text: String) -> AnyPublisher<ConversationAnalysis, Error> {
        let score = min(100, max(0, text.count % 100))
        let mock = ConversationAnalysis(
            riskScore: score,
            redFlags: ["Asks to move off-platform", "Urgency for payment"],
            recomendations: ["Ask for a short video call", "Don’t prepay"]
        )
        return  Just(mock)
            .delay(for: .milliseconds(400), scheduler: DispatchQueue.main)
            .setFailureType(to: Error.self)
            .eraseToAnyPublisher()
    }
    
}
//
//  SearchServiceImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import Combine

final class SearchServiceImpl: SearchService {
    func searchByName(_ query: String) -> AnyPublisher<[ImageHit],Error> {
        Just(query)
            .delay(for: .milliseconds(300), scheduler: DispatchQueue.main)
            .map { q in
                guard !q.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return [] }
                return (0..<3).map { i in
                    ImageHit(
                        title: "Result \(i+1) for '\(q)'",
                        source: "example.com",
                        thumbnailURL: URL(string: "https://picsum.photos/seed/\(q)\(i)/200/200") ,
                        linkURL: URL(string: "https://example.com/\(i)")
                    )
                }
            }
            .setFailureType(to: Error.self)
            .eraseToAnyPublisher()
    }
    
    func searchByImage(_ jpegData: Data) -> AnyPublisher<[ImageHit],Error> {
        Just((0..<3).map { i in
                  ImageHit(
                      title: "Similar \(i+1)",
                      source: "lens.example",
                      thumbnailURL: URL(string: "https://picsum.photos/seed/image\(i)/200/200"),
                      linkURL: URL(string: "https://example.com/vis\(i)")
                  )
              })
        .delay(for: .milliseconds(300), scheduler: DispatchQueue.main)
        .setFailureType(to: Error.self)
        .eraseToAnyPublisher()
    }
    
    
}
//
//  CheaterStore.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import Foundation


final class CheaterStoreImpl: CheaterStore {
    private let key = "cb.cheater.history.v1"
    private let limit = 10
    private let defaults: UserDefaults

    init(defaults: UserDefaults = .standard) {
        self.defaults = defaults
    }

    func load() -> [CheaterRecord] {
        guard let data = defaults.data(forKey: key) else { return [] }
        return (try? JSONDecoder().decode([CheaterRecord].self, from: data)) ?? []
    }

    func add(_ record: CheaterRecord) {
        var arr = load()
        // простая де-дупликация по (kind,risk,previewHash)
        if let d = record.previewJPEG {
            let h = d.hashValue
            arr.removeAll { $0.kind == record.kind && $0.riskScore == record.riskScore && ($0.previewJPEG?.hashValue == h) }
        }
        arr.insert(record, at: 0)
        if arr.count > limit { arr = Array(arr.prefix(limit)) }
        save(arr)
    }

    func clearAll() {
        defaults.removeObject(forKey: key)
    }

    private func save(_ arr: [CheaterRecord]) {
        if let data = try? JSONEncoder().encode(arr) {
            defaults.set(data, forKey: key)
        }
    }
}
//
//  CheaterAnalyzerService.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import Combine

public protocol CheaterAnalyzerService {
    func analyze(text: String) -> AnyPublisher<ConversationAnalysis,Error>
}
 
//
//  CheaterStore.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//



import Foundation

public protocol CheaterStore {
    func load() -> [CheaterRecord]
    func add(_ record: CheaterRecord)
    func clearAll()
}
//
//  SearchService.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Combine
import Foundation

public protocol SearchService {
    func searchByName(_ query: String) -> AnyPublisher<[ImageHit], Error>
    func searchByImage(_ jpegData: Data) -> AnyPublisher<[ImageHit],Error>
}
//
//  HistoryStore.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import Combine

public protocol HistoryStore {
    func load() -> [HistoryRecord]
    func add(_ record: HistoryRecord)
    func clearAll()
}
//
//  SettingsStore.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation

public protocol SettingsStore {
    var isHistoryEnabled: Bool { get set }
}
//
//  HistoryKind.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import Foundation
import UIKit

public enum HistoryKind: String, Codable {
    case name   // поиск по имени
    case face   // поиск по фото
}

public struct HistoryRecord: Identifiable, Codable {
    public let id: UUID
    public let createdAt: Date
    public let kind: HistoryKind

    // name-search
    public let query: String?

    // face-search (мини-превью jpeg)
    public let imageJPEG: Data?

    // опциональные подписи для превью
    public let titlePreview: String?
    public let sourcePreview: String?

    public init(id: UUID = UUID(),
                createdAt: Date = .init(),
                kind: HistoryKind,
                query: String? = nil,
                imageJPEG: Data? = nil,
                titlePreview: String? = nil,
                sourcePreview: String? = nil) {
        self.id = id
        self.createdAt = createdAt
        self.kind = kind
        self.query = query
        self.imageJPEG = imageJPEG
        self.titlePreview = titlePreview
        self.sourcePreview = sourcePreview
    }
}
//
//  ConversationAnalysis.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation

public struct ConversationAnalysis: Equatable {
    public let riskScore: Int
    public let redFlags: [String]
    public let recomendations: [String]
    
    init(riskScore: Int, redFlags: [String], recomendations: [String]) {
        self.riskScore = riskScore
        self.redFlags = redFlags
        self.recomendations = recomendations
    }
}
//
//  ImageHit.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation

public struct ImageHit: Identifiable, Hashable {
    public let id: UUID = UUID()
    public let title: String
    public let source: String
    public let thumbnailURL: URL?
    public let linkURL: URL?
    
    public init(title: String, source: String, thumbnailURL: URL?, linkURL: URL?) {
        self.title = title
        self.source = source
        self.thumbnailURL = thumbnailURL
        self.linkURL = linkURL
    }
}
//
//  CheaterRecord.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//



import Foundation
import UIKit

public enum CheaterSourceKind: String, Codable {
    case image   // анализ скриншота/фото
    case file    // анализ документа/файла
}

public struct CheaterRecord: Identifiable, Codable {
    public let id: UUID
    public let createdAt: Date
    public let kind: CheaterSourceKind
    public let riskScore: Int            // 0...100
    public let previewJPEG: Data?        // маленькая превьюшка (опц.)

    // опционально — краткий заголовок/примечание
    public let note: String?

    public init(id: UUID = UUID(),
                createdAt: Date = .init(),
                kind: CheaterSourceKind,
                riskScore: Int,
                previewJPEG: Data? = nil,
                note: String? = nil) {
        self.id = id
        self.createdAt = createdAt
        self.kind = kind
        self.riskScore = max(0, min(100, riskScore))
        self.previewJPEG = previewJPEG
        self.note = note
    }
}
//
//  SettingsView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import SwiftUI

struct SettingsScreen: View {
    @State private var isHistoryEnabled = true

    var body: some View {
        NavigationStack {
            Form {
                Toggle("Save history", isOn: $isHistoryEnabled)
            }
            .navigationTitle("Settings")
        }
    }
}
//
//  SettingsViewModel.swift
//  CheaterBuster
//

import Foundation
import Combine

final class SettingsViewModel: ObservableObject {
    @Published var isHistoryEnabled: Bool {
        didSet { store.isHistoryEnabled = isHistoryEnabled }
    }

    private var store: SettingsStore

    init(store: SettingsStore) {
        self.store = store
        self.isHistoryEnabled = store.isHistoryEnabled
    }
}
//
//  SearchViewModel.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

//
//  SearchViewModel.swift
//  CheaterBuster
//

import Foundation
import Combine
import UIKit

final class SearchViewModel: ObservableObject {

    // MARK: - Input
    @Published var query: String = ""

    // MARK: - Output
    @Published private(set) var results: [ImageHit] = []
    @Published private(set) var isLoading: Bool = false            // мелкие индикаторы (в кнопках)
    @Published private(set) var isBlockingLoading: Bool = false     // full-screen загрузка
    @Published private(set) var errorText: String?

    // MARK: - Deps
    private let search: SearchService
    private let history: HistoryStore
    // settings можно использовать позже (флаги, лимиты, т.п.)
    private let settings: SettingsStore?

    private var bag = Set<AnyCancellable>()

    // MARK: - Init
    init(search: SearchService,
         history: HistoryStore,
         settings: SettingsStore? = nil)
    {
        self.search = search
        self.history = history
        self.settings = settings
        bindQueryDebounce()
    }

    // MARK: - Debounce по вводу (без блокирующей загрузки)
    private func bindQueryDebounce() {
        $query
            .removeDuplicates()
            .debounce(for: .milliseconds(300), scheduler: DispatchQueue.main)
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            .flatMap { [weak self] q -> AnyPublisher<[ImageHit], Never> in
                guard let self, !q.isEmpty else { return Just([]).eraseToAnyPublisher() }
                // «тихий» поиск: не трогаем isBlockingLoading, можно не трогать и isLoading,
                // чтобы не мигал спиннер при наборе
                return self.search.searchByName(q)
                    .map { $0 }
                    .catch { [weak self] err -> AnyPublisher<[ImageHit], Never> in
                        self?.errorText = err.localizedDescription
                        return Just([]).eraseToAnyPublisher()
                    }
                    .eraseToAnyPublisher()
            }
            .receive(on: DispatchQueue.main)
            .assign(to: &$results)
    }

    // MARK: - Явный запуск по кнопке «Find»
    func runNameSearch() {
        let q = query.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !q.isEmpty else { return }

        isLoading = true
        isBlockingLoading = true
        errorText = nil

        search.searchByName(q)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                guard let self else { return }
                self.isLoading = false
                self.isBlockingLoading = false
                if case .failure(let err) = completion {
                    self.errorText = err.localizedDescription
                    self.results = []
                }
            } receiveValue: { [weak self] hits in
                guard let self else { return }
                self.results = hits

                // Сохраняем историю (только при успехе)
                let previewTitle  = hits.first?.title
                let previewSource = hits.first?.source
                let rec = HistoryRecord(
                    kind: .name,
                    query: q,
                    imageJPEG: nil,
                    titlePreview: previewTitle,
                    sourcePreview: previewSource
                )
                self.history.add(rec)
            }
            .store(in: &bag)
    }

    // MARK: - Запуск по кнопке «Analyze» (по фото)
    func runImageSearch(jpegData: Data) {
        isLoading = true
        isBlockingLoading = true
        errorText = nil

        search.searchByImage(jpegData)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                guard let self else { return }
                self.isLoading = false
                self.isBlockingLoading = false
                if case .failure(let err) = completion {
                    self.errorText = err.localizedDescription
                    self.results = []
                }
            } receiveValue: { [weak self] hits in
                guard let self else { return }
                self.results = hits

                // Мини-превью для истории (жмем сильнее, чтобы экономить место)
                let thumbData = (UIImage(data: jpegData)?
                    .jpegData(compressionQuality: 0.5)) ?? jpegData

                let rec = HistoryRecord(
                    kind: .face,
                    query: nil,
                    imageJPEG: thumbData,
                    titlePreview: hits.first?.title,
                    sourcePreview: hits.first?.source
                )
                self.history.add(rec)
            }
            .store(in: &bag)
    }

    // MARK: - Прочее (если нужно использовать)
    func resetResults() {
        results = []
        errorText = nil
    }
}
//
//  FaceSearchView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//

import SwiftUI
import PhotosUI
import UIKit

struct FaceSearchView: View {
    @ObservedObject var vm: SearchViewModel
    @Environment(\.dismiss) private var dismiss

    @State private var item: PhotosPickerItem?
    @State private var image: UIImage?

    @State private var goResults = false
    @State private var didAnalyze = false

    var body: some View {
        ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            VStack(spacing: Tokens.Spacing.x16) {
                // Header
                HStack {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "arrow.left")
                            .font(.system(size: 16, weight: .semibold))
                            .foregroundStyle(Tokens.Color.textPrimary)
                            .padding(12)
                            .background(
                                Tokens.Color.surfaceCard,
                                in: RoundedRectangle(cornerRadius: 16, style: .continuous)
                            )
                            .apply(Tokens.Shadow.card)
                    }

                    Spacer()

                    Text("Face search")
                        .font(Tokens.Font.title)
                        .foregroundStyle(Tokens.Color.textPrimary)

                    Spacer().frame(width: 44)
                }
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.top, Tokens.Spacing.x16)

                // Preview
                Group {
                    if let img = image {
                        Image(uiImage: img)
                            .resizable()
                            .scaledToFit()
                            .frame(maxWidth: .infinity)
                            .padding(.horizontal, Tokens.Spacing.x16)
                            .padding(.top, Tokens.Spacing.x12)
                            .clipShape(RoundedRectangle(cornerRadius: 22, style: .continuous))
                            .overlay(
                                RoundedRectangle(cornerRadius: 22, style: .continuous)
                                    .stroke(Tokens.Color.borderNeutral, lineWidth: 1)
                            )
                    } else {
                        ContentUnavailableView(
                            "Select a photo",
                            systemImage: "photo",
                            description: Text("Pick one image to search by face.")
                        )
                        .padding(.horizontal, Tokens.Spacing.x16)
                        .padding(.top, Tokens.Spacing.x32)
                    }
                }

                Spacer(minLength: 0)
            }
        }
        .navigationBarBackButtonHidden(true)

        // Bottom tools panel (как на макете)
        .safeAreaInset(edge: .bottom) {
            HStack(spacing: Tokens.Spacing.x16) {
                CircleTool(system: "rotate.left")  { /* позже */ }
                CircleTool(system: "rotate.right") { /* позже */ }
                CircleTool(system: "crop")         { /* позже */ }

                Spacer()

                // Pink CTA →
                Button {
                    guard let img = image,
                          let jpeg = img.jpegData(compressionQuality: 0.85) else { return }
                    didAnalyze = true
                    vm.runImageSearch(jpegData: jpeg)
                } label: {
                    Image(systemName: "arrow.right")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundStyle(.white)
                        .frame(width: 52, height: 52)
                        .background(
                            Tokens.Color.accent,
                            in: Circle()
                        )
                        .shadow(color: .black.opacity(0.12), radius: 8, y: 4)
                }
                .buttonStyle(.plain)
                .disabled(image == nil || vm.isLoading)
            }
            .padding(.horizontal, Tokens.Spacing.x20)
            .padding(.vertical, Tokens.Spacing.x16)
            .background(
                Tokens.Color.surfaceCard,
                ignoresSafeAreaEdges: .bottom
            )
        }

        // PhotosPicker (кнопка из верхней зоны не нужна – откроем по тапу на превью-заглушку)
        .photosPicker(isPresented: Binding(
            get: { image == nil && item == nil }, set: { _ in }
        ), selection: $item, matching: .images)

        .onChange(of: item) { _, newValue in
            Task { @MainActor in
                guard let data = try? await newValue?.loadTransferable(type: Data.self),
                      let img = UIImage(data: data) else { return }
                image = img
            }
        }

        // Навигация к результатам
        .onChange(of: vm.isLoading) { was, isNow in
            if didAnalyze && was == true && isNow == false {
                didAnalyze = false
                goResults = true
            }
        }
        .navigationDestination(isPresented: $goResults) {
            SearchResultsView(results: vm.results, mode: .face)
        }

        // Loading over fullscreen (с превью и прогрессом)
        .fullScreenCover(
            isPresented: Binding(
                get: { vm.isBlockingLoading },
                set: { _ in }
            )
        ) {
            LoadingView(mode: .face, previewImage: image, cancelAction: nil)
                .interactiveDismissDisabled(true)
        }
    }
}

private struct CircleTool: View {
    let system: String
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            Image(systemName: system)
                .font(.system(size: 16, weight: .semibold))
                .foregroundStyle(Tokens.Color.textPrimary)
                .frame(width: 48, height: 48)
                .background(
                    Tokens.Color.backgroundMain,
                    in: Circle()
                )
                .shadow(color: .black.opacity(0.08), radius: 10, y: 4)
        }
        .buttonStyle(.plain)
    }
}
//
//  SearchScreen.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import SwiftUI

struct SearchScreen: View {
    @State private var goName = false
    @State private var goPhoto = false
    private let vm: SearchViewModel

    init(vm: SearchViewModel) { self.vm = vm }

    var body: some View {
        NavigationStack {
            VStack(spacing: Tokens.Spacing.x16) {
                Text("Find your partner")
                    .font(Tokens.Font.h2)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(.top, Tokens.Spacing.x8)

                VStack(spacing: Tokens.Spacing.x12) {
                    CardRow(
                        icon: "text.magnifyingglass",
                        title: "Search for a partner by name"
                    ) { goName = true }

                    CardRow(
                        icon: "face.smiling",
                        title: "Finding a partner by face"
                    ) { goPhoto = true }        
                }

                Spacer()
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .background(Tokens.Color.backgroundMain.ignoresSafeArea())

            // ⬇️ ОБА destination — ВНУТРИ NavigationStack
            .navigationDestination(isPresented: $goName) {
                NameSearchView(vm: vm)
            }
            .navigationDestination(isPresented: $goPhoto) {
                FaceSearchView(vm: vm)
            }
        }
    }
}

private struct CardRow: View {
    let icon: String
    let title: String
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            HStack(spacing: Tokens.Spacing.x12) {
                Image(systemName: icon)
                    .frame(width: 28, height: 28)
                    .foregroundStyle(Tokens.Color.accent)
                    .background(
                        Tokens.Color.accent.opacity(0.1),
                        in: RoundedRectangle(cornerRadius: 8, style: .continuous)
                    )
                Text(title)
                    .foregroundStyle(Tokens.Color.textPrimary)
                Spacer()
            }
            .padding(.vertical, Tokens.Spacing.x12)
            .padding(.horizontal, Tokens.Spacing.x12)
            .background(
                Tokens.Color.surfaceCard,
                in: RoundedRectangle(cornerRadius: 16, style: .continuous)
            )
            .shadow(color: .black.opacity(0.06), radius: 8, y: 2)
        }
        .buttonStyle(.plain)
    }
}
//
//  NameSearchView.swift
//  CheaterBuster
//

import SwiftUI

struct NameSearchView: View {
    @ObservedObject var vm: SearchViewModel
    @Environment(\.dismiss) private var dismiss

    @State private var goResults = false
    @State private var didSubmit = false

    var body: some View {
        ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            VStack(alignment: .leading, spacing: Tokens.Spacing.x16) {
                // Header
                HStack {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "arrow.left")
                            .font(.system(size: 16, weight: .semibold))
                            .foregroundStyle(Tokens.Color.textPrimary)
                            .padding(12)
                            .background(
                                Tokens.Color.surfaceCard,
                                in: RoundedRectangle(cornerRadius: 16, style: .continuous)
                            )
                            .apply(Tokens.Shadow.card)
                    }

                    Spacer()

                    Text("Name search")
                        .font(Tokens.Font.title)
                        .foregroundStyle(Tokens.Color.textPrimary)

                    Spacer().frame(width: 44) // симметрия
                }
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.top, Tokens.Spacing.x16)

                // Search field
                VStack(spacing: Tokens.Spacing.x16) {
                    SearchField("Partner's name...", text: $vm.query)
                        .padding(.horizontal, Tokens.Spacing.x16)

                    Spacer(minLength: Tokens.Spacing.x16)
                }
            }
        }
        .navigationBarBackButtonHidden(true)
        .navigationBarTitleDisplayMode(.inline)

        // Нижняя большая кнопка Find
        .safeAreaInset(edge: .bottom) {
            HStack {
                PrimaryButton(
                    "Find",
                    isLoading: vm.isLoading,
                    isDisabled: vm.query.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty || vm.isLoading
                ) {
                    didSubmit = true
                    vm.runNameSearch()
                }
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.vertical, Tokens.Spacing.x16)
            .background(
                Tokens.Color.backgroundMain,
                ignoresSafeAreaEdges: .bottom
            )
        }

        // Когда блокирующая загрузка завершилась после нажатия — переходим к результатам
        .onChange(of: vm.isLoading) { was, isNow in
            if didSubmit && was == true && isNow == false {
                didSubmit = false
                goResults = true
            }
        }
        .navigationDestination(isPresented: $goResults) {
            SearchResultsView(results: vm.results, mode: .name)
        }

        // Фуллскрин загрузка (computed Binding — без попытки записывать обратно)
        .fullScreenCover(
            isPresented: Binding(
                get: { vm.isBlockingLoading },
                set: { _ in }
            )
        ) {
            LoadingView(mode: .name, previewImage: nil, cancelAction: nil)
                .interactiveDismissDisabled(true)
        }
    }
}
//
//  SearchResultsView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import SwiftUI

struct SearchResultsView: View {
    enum Mode { case face, name }

    let results: [ImageHit]
    let mode: Mode

    private let columns = [
        GridItem(.flexible(), spacing: Tokens.Spacing.x16),
        GridItem(.flexible(), spacing: Tokens.Spacing.x16)
    ]

    @Namespace private var ns

    var body: some View {
        ScrollView {
            if results.isEmpty {
                ContentUnavailableView(
                    "No results found",
                    systemImage: "magnifyingglass.circle",
                    description: Text("No matches found. Please try a different photo or name.")
                )
                .padding(.top, Tokens.Spacing.x24)
            } else {
                LazyVGrid(columns: columns, spacing: Tokens.Spacing.x16) {
                    ForEach(results) { hit in
                        if mode == .face {
                            FaceResultCard(hit: hit)
                        } else {
                            NameResultCard(hit: hit)
                        }
                    }
                }
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.vertical, Tokens.Spacing.x24)
                .animation(.easeInOut(duration: 0.25), value: results)
            }
        }
        .background(Tokens.Color.backgroundMain.ignoresSafeArea())
        .navigationTitle(mode == .face ? "Face results" : "Name results")
        .navigationBarTitleDisplayMode(.inline)
    }
}

// MARK: - Cards

private struct FaceResultCard: View {
    let hit: ImageHit

    var body: some View {
        VStack(spacing: Tokens.Spacing.x8) {
            AsyncThumb(url: hit.thumbnailURL)
                .frame(height: 160)
                .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            Tokens.Color.surfaceCard,
            in: RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
        )
        .apply(Tokens.Shadow.card)
    }
}

private struct NameResultCard: View {
    let hit: ImageHit

    var body: some View {
        VStack(alignment: .leading, spacing: Tokens.Spacing.x8) {
            AsyncThumb(url: hit.thumbnailURL)
                .frame(height: 160)
                .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))

            VStack(alignment: .leading, spacing: 2) {
                Text(hit.title)
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.textPrimary)
                    .lineLimit(1)
                Text(hit.source)
                    .font(Tokens.Font.captionRegular)
                    .foregroundStyle(Tokens.Color.textSecondary)
                    .lineLimit(1)
            }

            if let url = hit.linkURL {
                Link(destination: url) {
                    HStack(spacing: 4) {
                        Text("Open")
                        Image(systemName: "arrow.up.right.square")
                    }
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.accent)
                }
                .padding(.top, Tokens.Spacing.x4)
            }
        }
        .padding(Tokens.Spacing.x12)
        .background(
            Tokens.Color.surfaceCard,
            in: RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
        )
        .apply(Tokens.Shadow.card)
    }
}

private struct AsyncThumb: View {
    let url: URL?
    var body: some View {
        AsyncImage(url: url) { phase in
            switch phase {
            case .empty:
                ZStack { Color.gray.opacity(0.1); ProgressView() }
            case .success(let image):
                image.resizable().scaledToFill().clipped()
            case .failure:
                ZStack {
                    Color.gray.opacity(0.2)
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundStyle(.gray)
                }
            @unknown default:
                EmptyView()
            }
        }
    }
}
//
//  LoadingView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import SwiftUI

struct LoadingView: View {
    enum Mode { case name, face }

    let mode: Mode
    let previewImage: UIImage?
    let cancelAction: (() -> Void)?

    @State private var progress: CGFloat = 0.35 // моковый прогресс для визуала

    var body: some View {
        ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            VStack(spacing: Tokens.Spacing.x24) {
                if mode == .face, let ui = previewImage {
                    Image(uiImage: ui)
                        .resizable()
                        .scaledToFit()
                        .frame(maxWidth: .infinity)
                        .frame(height: 260)
                        .padding(.horizontal, Tokens.Spacing.x16)
                        .clipShape(RoundedRectangle(cornerRadius: 22, style: .continuous))
                        .overlay(
                            RoundedRectangle(cornerRadius: 22, style: .continuous)
                                .stroke(Tokens.Color.borderNeutral, lineWidth: 1)
                        )

                    Text("Photo analysis")
                        .font(Tokens.Font.bodyMedium18)
                        .foregroundStyle(Tokens.Color.textPrimary)

                    // Простой прогресс (визуальный)
                    ZStack(alignment: .leading) {
                        Capsule().fill(Tokens.Color.borderNeutral.opacity(0.4)).frame(height: 8)
                        Capsule().fill(Tokens.Color.accent).frame(width: progressWidth, height: 8)
                    }
                    .padding(.horizontal, Tokens.Spacing.x16)
                } else {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: Tokens.Color.accent))
                        .scaleEffect(1.6)

                    Text("Searching...")
                        .font(Tokens.Font.bodyMedium18)
                        .foregroundStyle(Tokens.Color.textPrimary)
                }

                if let cancelAction {
                    Button("Cancel") { cancelAction() }
                        .font(Tokens.Font.caption)
                        .foregroundStyle(Tokens.Color.textSecondary)
                        .padding(.top, Tokens.Spacing.x8)
                }

                Spacer(minLength: 0)
            }
            .padding(.top, Tokens.Spacing.x24)
        }
        .onAppear {
            // лёгкая псевдо-анимация прогресса
            withAnimation(.easeInOut(duration: 0.9).repeatForever(autoreverses: true)) {
                progress = 0.7
            }
        }
    }

    private var progressWidth: CGFloat {
        // просто визуально — 35..70% ширины экрана
        UIScreen.main.bounds.width * progress
    }
}
//
//  HistoryViewModel.swift
//  CheaterBuster
//

import Foundation
import Combine
import UIKit

final class HistoryViewModel: ObservableObject {
    // MARK: Search-history
    @Published private(set) var items: [HistoryRecord] = []

    // MARK: Cheater-history
    @Published private(set) var cheaterItems: [CheaterRecord] = []

    @Published var segment: Segment = .search
    enum Segment: Equatable { case search, cheater }

    // Навигация/статусы для реплея поиска
    @Published private(set) var rerunResults: [ImageHit] = []
    @Published private(set) var isLoading = false
    @Published var errorText: String?

    private let store: HistoryStore
    private let cheaterStore: CheaterStore
    private let search: SearchService
    private var bag = Set<AnyCancellable>()

    init(store: HistoryStore,
         cheaterStore: CheaterStore,
         search: SearchService) {
        self.store = store
        self.cheaterStore = cheaterStore
        self.search = search
        reload()
    }

    func reload() {
        items = store.load()
        cheaterItems = cheaterStore.load()
    }

    // MARK: Search tab
    func clearSearch() {
        store.clearAll()
        items = []
    }

    func onTapSearch(_ rec: HistoryRecord) {
        // повтор поиска
        isLoading = true
        errorText = nil

        let pub: AnyPublisher<[ImageHit], Error>
        if rec.kind == .name, let q = rec.query {
            pub = search.searchByName(q)
        } else if rec.kind == .face, let data = rec.imageJPEG {
            pub = search.searchByImage(data)
        } else {
            isLoading = false
            return
        }

        pub
            .receive(on: DispatchQueue.main)
            .sink { [weak self] comp in
                self?.isLoading = false
                if case .failure(let err) = comp {
                    self?.errorText = err.localizedDescription
                }
            } receiveValue: { [weak self] hits in
                self?.rerunResults = hits
            }
            .store(in: &bag)
    }

    // MARK: Cheater tab
    func clearCheater() {
        cheaterStore.clearAll()
        cheaterItems = []
    }

    // На этом шаге «повтор анализа» не включаем, просто оставим заглушку.
    // Позже, когда подключим CheaterService, откроем экран результата/реплей задачи.
    func onTapCheater(_ rec: CheaterRecord) {
        // TODO: navigate to CheaterResultView (в следующем шаге)
    }
}
//
//  HistoryView.swift
//  CheaterBuster
//

import SwiftUI

struct HistoryView: View {
    @StateObject var vm: HistoryViewModel
    @State private var goResults = false

    var body: some View {
        VStack(spacing: 0) {
            // Title
            HStack {
                Text("History")
                    .font(Tokens.Font.title)
                    .foregroundStyle(Tokens.Color.textPrimary)
                Spacer()
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.top, Tokens.Spacing.x16)

            // Segment
            SegmentCapsule(selected: $vm.segment)
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.top, Tokens.Spacing.x12)

            // Content
            Group {
                if vm.segment == .search {
                    topBarClear(isHidden: vm.items.isEmpty) { vm.clearSearch() }
                    HistoryGrid(items: vm.items) { rec in
                        vm.onTapSearch(rec)
                    }
                    .padding(.horizontal, Tokens.Spacing.x16)
                    .padding(.top, Tokens.Spacing.x16)
                } else {
                    topBarClear(isHidden: vm.cheaterItems.isEmpty) { vm.clearCheater() }
                    CheaterList(items: vm.cheaterItems) { rec in
                        vm.onTapCheater(rec)
                    }
                    .padding(.horizontal, Tokens.Spacing.x16)
                    .padding(.top, Tokens.Spacing.x16)
                }
            }

            Spacer(minLength: 0)
        }
        .background(Tokens.Color.backgroundMain.ignoresSafeArea())
        .navigationBarTitleDisplayMode(.inline)

        // Search rerun -> results
        .onChange(of: vm.rerunResults) { _, hits in
            if !hits.isEmpty { goResults = true }
        }
        .navigationDestination(isPresented: $goResults) {
            SearchResultsView(results: vm.rerunResults, mode: .name)
        }
    }

    // small helper
    @ViewBuilder
    private func topBarClear(isHidden: Bool, action: @escaping () -> Void) -> some View {
        HStack {
            Spacer()
            if !isHidden {
                Button("Clear") { action() }
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.accent)
            }
        }
        .padding(.horizontal, Tokens.Spacing.x16)
        .padding(.top, Tokens.Spacing.x8)
    }
}

// MARK: - Segment

private struct SegmentCapsule: View {
    @Binding var selected: HistoryViewModel.Segment
    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 22, style: .continuous)
                .fill(Tokens.Color.surfaceCard)
                .apply(Tokens.Shadow.card)

            HStack(spacing: 0) {
                seg("Search", .search)
                seg("Cheater", .cheater)
            }
        }
        .frame(height: 44)
    }

    private func seg(_ title: String, _ seg: HistoryViewModel.Segment) -> some View {
        Button { selected = seg } label: {
            Text(title)
                .font(Tokens.Font.caption)
                .foregroundStyle(selected == seg ? .white : Tokens.Color.textPrimary)
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(
                    Group {
                        if selected == seg {
                            RoundedRectangle(cornerRadius: 22, style: .continuous)
                                .fill(Tokens.Color.accent)
                        }
                    }
                )
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Search grid (как раньше)

private struct HistoryGrid: View {
    let items: [HistoryRecord]
    let onTap: (HistoryRecord) -> Void

    private let columns = [
        GridItem(.flexible(), spacing: Tokens.Spacing.x16),
        GridItem(.flexible(), spacing: Tokens.Spacing.x16)
    ]

    var body: some View {
        if items.isEmpty {
            ContentUnavailableView("No history yet",
                                   systemImage: "clock.arrow.circlepath",
                                   description: Text("Your last 10 searches will appear here."))
                .padding(.top, Tokens.Spacing.x24)
        } else {
            ScrollView {
                LazyVGrid(columns: columns, spacing: Tokens.Spacing.x16) {
                    ForEach(items) { rec in
                        Button { onTap(rec) } label: {
                            HistoryCard(rec: rec)
                        }
                        .buttonStyle(.plain)
                    }
                }
                .padding(.bottom, Tokens.Spacing.x24)
            }
        }
    }
}

private struct HistoryCard: View {
    let rec: HistoryRecord
    var body: some View {
        VStack(alignment: .leading, spacing: Tokens.Spacing.x8) {
            if rec.kind == .face, let d = rec.imageJPEG, let img = UIImage(data: d) {
                Image(uiImage: img)
                    .resizable()
                    .scaledToFill()
                    .frame(height: 150)
                    .clipped()
                    .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))
            } else {
                ZStack {
                    Tokens.Color.backgroundMain
                    Image(systemName: "person.text.rectangle")
                        .font(.system(size: 28))
                        .foregroundStyle(Tokens.Color.textSecondary)
                }
                .frame(height: 150)
                .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))
            }
            if let q = rec.query {
                Text(q).font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.textPrimary)
                    .lineLimit(1)
            }
            if let s = rec.sourcePreview {
                Text(s).font(Tokens.Font.captionRegular)
                    .foregroundStyle(Tokens.Color.textSecondary)
                    .lineLimit(1)
            }
        }
        .padding(Tokens.Spacing.x12)
        .background(
            Tokens.Color.surfaceCard,
            in: RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
        )
        .apply(Tokens.Shadow.card)
    }
}

// MARK: - Cheater list

private struct CheaterList: View {
    let items: [CheaterRecord]
    let onTap: (CheaterRecord) -> Void

    var body: some View {
        if items.isEmpty {
            ContentUnavailableView("No cheater items yet",
                                   systemImage: "text.magnifyingglass",
                                   description: Text("Analyze a chat to see it here."))
                .padding(.top, Tokens.Spacing.x24)
        } else {
            ScrollView {
                VStack(spacing: Tokens.Spacing.x12) {
                    ForEach(items) { rec in
                        Button { onTap(rec) } label: {
                            CheaterRow(rec: rec)
                        }
                        .buttonStyle(.plain)
                    }
                }
                .padding(.bottom, Tokens.Spacing.x24)
            }
        }
    }
}

private struct CheaterRow: View {
    let rec: CheaterRecord

    var body: some View {
        HStack(spacing: Tokens.Spacing.x12) {
            // Левая иконка (как в макете)
            ZStack {
                Tokens.Color.backgroundMain
                Image(systemName: rec.kind == .file ? "folder" : "photo")
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundStyle(Tokens.Color.accent)
            }
            .frame(width: 44, height: 44)
            .clipShape(RoundedRectangle(cornerRadius: 14, style: .continuous))

            VStack(alignment: .leading, spacing: 4) {
                Text("High risk level")
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.textPrimary)
                if let note = rec.note, !note.isEmpty {
                    Text(note)
                        .font(Tokens.Font.captionRegular)
                        .foregroundStyle(Tokens.Color.textSecondary)
                        .lineLimit(1)
                }
            }

            Spacer()

            // % справа
            Text("\(rec.riskScore)%")
                .font(Tokens.Font.caption)
                .foregroundStyle(Tokens.Color.textPrimary)
        }
        .padding(.vertical, Tokens.Spacing.x12)
        .padding(.horizontal, Tokens.Spacing.x12)
        .background(
            Tokens.Color.surfaceCard,
            in: RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
        )
        .apply(Tokens.Shadow.card)
    }
}
//
//  CheaterViewModel.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import Combine

final class CheaterViewModel: ObservableObject {
    @Published var inputText: String = ""
    @Published private(set) var result: ConversationAnalysis?
    @Published private(set) var isLoading: Bool = false
    @Published private(set) var errorText: String?
    
    private let analyzer: CheaterAnalyzerService
    private var bag = Set<AnyCancellable>()
    
    
    init(analyzer: CheaterAnalyzerService) {
        self.analyzer = analyzer
    }
    
}
//
//  CheaterScreen.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import SwiftUI

struct CheaterScreen: View {
    @State private var text: String = ""
    var body: some View {
        NavigationStack {
            VStack(spacing:16) {
                Text("Paste conversation text to analyze")
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.textSecondary)
                
                TextEditor(text: $text)
                    .frame(minHeight: 160)
                    .padding(8)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .stroke(Tokens.Color.borderNeutral, lineWidth: 1)
                    )
                PrimaryButton("Analyze", isDisabled: text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ) {
                    
                }
                Spacer()
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.top, Tokens.Spacing.x24)
            .background(Tokens.Color.backgroundMain.ignoresSafeArea())
            .navigationTitle("Cheater")
        }
    }
}
