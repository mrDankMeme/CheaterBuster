//
//  InMemoryTokenStorage.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation

final class InMemoryTokenStorage: TokenStorage {
    var accessToken: String?
    var userId: String?
}

//
//  MultipartFormData.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


// сборщик multipart-запросов

import Foundation

struct MultipartFormData {
    struct FilePart {
        let name: String
        let filename: String
        let mimeType: String
        let data: Data
    }
    
    private let boundary = "----CB-\(UUID().uuidString)"
    var contentType: String { "multipart/form-data; boundary=\(boundary)" }
    
    func build(fields: [String: String?], files: [FilePart]) -> Data {
        var body = Data()
        for (k,v) in fields { guard let v else { continue }
            body.append("--\(boundary)\r\n")
            body.append("Content-Disposition: form-data; name=\"\(k)\"\r\n\r\n")
            body.append("\(v)\r\n")
        }
        for f in files {
            body.append("--\(boundary)\r\n")
            body.append("Content-Disposition: form-data; name=\"\(f.name)\"; filename=\"\(f.filename)\"\r\n")
            body.append("Content-Type: \(f.mimeType)\r\n\r\n")
            body.append(f.data); body.append("\r\n")
        }
        body.append("--\(boundary)--\r\n")
        return body
    }
}
private extension Data {
    mutating func append(_ s: String) {
        if let d = s.data(using: .utf8) {
            append(d)
        }
    }
}
//
//  URLSessionHTTPClient.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//



import Foundation

final class URLSessionHTTPClient: HTTPClient {
    private let session: URLSession
    init(session: URLSession = .shared) { self.session = session }

    func send<T: Decodable>(_ request: URLRequest) async throws -> T {
        var req = request
        if req.value(forHTTPHeaderField: "Accept") == nil {
            req.setValue("application/json", forHTTPHeaderField: "Accept")
        }
        let (data, resp): (Data, URLResponse)
        do {
            (data, resp) = try await session.data(for: req)
        } catch {
            throw APIError.transport(error)
        }
        guard let http = resp as? HTTPURLResponse else { throw APIError.noData }
        guard (200..<300).contains(http.statusCode) else {
            if http.statusCode == 401 { throw APIError.unauthorized }
            let body = String(data: data, encoding: .utf8)
            throw APIError.http(http.statusCode, body)
        }
        do {
            return try JSONDecoder().decode(T.self, from: data)
        } catch {
            throw APIError.decoding(error)
        }
    }

    func sendVoid(_ request: URLRequest) async throws {
        var req = request
        if req.value(forHTTPHeaderField: "Accept") == nil {
            req.setValue("application/json", forHTTPHeaderField: "Accept")
        }
        let (data, resp) = try await session.data(for: req)
        guard let http = resp as? HTTPURLResponse else { throw APIError.noData }
        guard (200..<300).contains(http.statusCode) else {
            if http.statusCode == 401 { throw APIError.unauthorized }
            let body = String(data: data, encoding: .utf8)
            throw APIError.http(http.statusCode, body)
        }
        _ = data
    }
}
//
//  APIConfig.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation

struct APIConfig {
    let baseURL: URL
    let bundleId: String = Bundle.main.bundleIdentifier ?? "dev.cheaterbuster"
}
//
//  PermissionsManagerImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//



import Foundation
import AppTrackingTransparency   // MARK: - Added
import AdSupport                 // MARK: - Added
import Photos                    // MARK: - Added
import AVFoundation              // MARK: - Added
import UserNotifications         // MARK: - Added

final class PermissionsManagerImpl: PermissionsManager {

    // MARK: - Status

    func status(of permission: Permission) async -> PermissionStatus {
        switch permission {
        case .tracking:
            if #available(iOS 14, *) {
                switch ATTrackingManager.trackingAuthorizationStatus {
                case .authorized:   return .authorized
                case .denied:       return .denied
                case .restricted:   return .restricted
                case .notDetermined:return .notDetermined
                @unknown default:   return .temporarilyUnavailable
                }
            } else {
                return .unsupported
            }

        case .notifications:
            let settings = await UNUserNotificationCenter.current().notificationSettings()
            switch settings.authorizationStatus {
            case .authorized, .provisional, .ephemeral: return .authorized
            case .denied:       return .denied
            case .notDetermined:return .notDetermined
            @unknown default:   return .temporarilyUnavailable
            }

        case .photoLibrary:
            let s = PHPhotoLibrary.authorizationStatus(for: .readWrite)
            switch s {
            case .authorized, .limited: return .authorized
            case .denied:       return .denied
            case .restricted:   return .restricted
            case .notDetermined:return .notDetermined
            @unknown default:   return .temporarilyUnavailable
            }

        case .camera:
            let s = AVCaptureDevice.authorizationStatus(for: .video)
            switch s {
            case .authorized:   return .authorized
            case .denied:       return .denied
            case .restricted:   return .restricted
            case .notDetermined:return .notDetermined
            @unknown default:   return .temporarilyUnavailable
            }

        case .files:
            // На iOS доступ к файлам идёт через UIDocumentPicker (пермишна нет).
            return .authorized
        }
    }

    // MARK: - Request

    func request(_ permission: Permission) async -> PermissionStatus {
        switch permission {
        case .tracking:
            if #available(iOS 14, *) {
                let current = await status(of: .tracking)
                if current != .notDetermined { return current }
                let result = await withCheckedContinuation { (continuation: CheckedContinuation<PermissionStatus, Never>) in
                    ATTrackingManager.requestTrackingAuthorization { status in
                        switch status {
                        case .authorized:   continuation.resume(returning: .authorized)
                        case .denied:       continuation.resume(returning: .denied)
                        case .restricted:   continuation.resume(returning: .restricted)
                        case .notDetermined:continuation.resume(returning: .notDetermined)
                        @unknown default:   continuation.resume(returning: .temporarilyUnavailable)
                        }
                    }
                }
                _ = ASIdentifierManager.shared().advertisingIdentifier // «пробуждение» фреймворка
                return result
            } else {
                return .unsupported
            }

        case .notifications:
            let current = await status(of: .notifications)
            if current != .notDetermined { return current }
            do {
                let granted = try await UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound])
                return granted ? .authorized : .denied
            } catch {
                return .temporarilyUnavailable
            }

        case .photoLibrary:
            let current = await status(of: .photoLibrary)
            if current != .notDetermined { return current }
            return await withCheckedContinuation { (continuation: CheckedContinuation<PermissionStatus, Never>) in
                PHPhotoLibrary.requestAuthorization(for: .readWrite) { s in
                    switch s {
                    case .authorized, .limited: continuation.resume(returning: .authorized)
                    case .denied:       continuation.resume(returning: .denied)
                    case .restricted:   continuation.resume(returning: .restricted)
                    case .notDetermined:continuation.resume(returning: .notDetermined)
                    @unknown default:   continuation.resume(returning: .temporarilyUnavailable)
                    }
                }
            }

        case .camera:
            let current = await status(of: .camera)
            if current != .notDetermined { return current }
            let granted = await withCheckedContinuation { (continuation: CheckedContinuation<Bool, Never>) in
                AVCaptureDevice.requestAccess(for: .video) { granted in
                    continuation.resume(returning: granted)
                }
            }
            return granted ? .authorized : .denied

        case .files:
            // Пермишна нет, считаем доступ разрешён (UIDocumentPicker сам покажет системный UI).
            return .authorized
        }
    }
}
//
//  ContentView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//


import SwiftUI
import Swinject

struct DemoView: View {
    @State private var query = ""
    @Environment(\.resolver) private var resolver
    var body: some View {
        NavigationStack {
            Text("Boot OK")
            Text("Resolver hash: \(ObjectIdentifier(resolver as AnyObject).hashValue)")

                .font(.caption)
                .foregroundStyle(.secondary)
            VStack(spacing: Tokens.Spacing.x24) {
                SearchField("Partner's name...", text: $query)

                PrimaryButton("Find", isDisabled: query.isEmpty) {
                    // позже добавим действие
                }

                Spacer()
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.top, Tokens.Spacing.x24)
            .background(Tokens.Color.backgroundMain.ignoresSafeArea())
            .navigationTitle("CheaterBuster")
        }
    }
}

//
//  PrimaryButton.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//

import SwiftUI

public struct PrimaryButton: View {
    public enum Size { case large, medium }

    let title: String
    let size: Size
    let isLoading: Bool
    let isDisabled: Bool
    let action: () -> Void

    public init(_ title: String,
                size: Size = .large,
                isLoading: Bool = false,
                isDisabled: Bool = false,
                action: @escaping () -> Void) {
        self.title = title
        self.size = size
        self.isLoading = isLoading
        self.isDisabled = isDisabled
        self.action = action
    }

    public var body: some View {
        Button(action: action) {
            ZStack {
                if isLoading {
                    ProgressView().tint(.white)
                } else {
                    Text(title)
                        .font(Tokens.Font.subtitle)
                        .foregroundColor(.white)
                        .lineLimit(1)
                }
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, size == .large ? 16 : 12)
            // iOS-style corner smoothing (.continuous)
            .background(
                (isDisabled ? Tokens.Color.accentPressed : Tokens.Color.accent),
                in: RoundedRectangle(cornerRadius: Tokens.Radius.pill, style: .continuous)
            )
        }
        .buttonStyle(.plain)
        .disabled(isDisabled || isLoading)
        .accessibilityAddTraits(.isButton)
    }
}
//
//  SearchField.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//

import SwiftUI

public struct SearchField: View {
    @Binding var text: String
    var placeholder: String
    var onCommit: (() -> Void)?
    var onCancel: (() -> Void)?

    @FocusState private var focused: Bool

    public init(_ placeholder: String,
                text: Binding<String>,
                onCommit: (() -> Void)? = nil,
                onCancel: (() -> Void)? = nil) {
        self.placeholder = placeholder
        self._text = text
        self.onCommit = onCommit
        self.onCancel = onCancel
    }

    public var body: some View {
        HStack(spacing: Tokens.Spacing.x12) {
            HStack(spacing: Tokens.Spacing.x12) {
                Image(systemName: "magnifyingglass")
                    .foregroundColor(Tokens.Color.textSecondary)

                TextField(placeholder, text: $text)
                    .font(Tokens.Font.body)
                    .foregroundColor(Tokens.Color.textPrimary)
                    .focused($focused)
                    .submitLabel(.search)
                    .onSubmit { onCommit?() }

                if !text.isEmpty {
                    Button {
                        text = ""
                    } label: {
                        Image(systemName: "xmark")
                            .foregroundColor(Tokens.Color.textSecondary)
                    }
                    .accessibilityLabel("Clear text")
                }
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.vertical, 12)
            .background(
                Tokens.Color.surfaceCard,
                in: RoundedRectangle(cornerRadius: Tokens.Radius.pill, style: .continuous)
            )
            .overlay(
                RoundedRectangle(cornerRadius: Tokens.Radius.pill, style: .continuous)
                    .stroke(Tokens.Color.borderNeutral, lineWidth: 1)
            )
            .apply(Tokens.Shadow.card)

            if focused {
                Button("Cancel") {
                    text = ""
                    focused = false
                    onCancel?()
                }
                .font(Tokens.Font.body)
                .foregroundColor(Tokens.Color.textSecondary)
                .transition(.opacity.combined(with: .move(edge: .trailing)))
            }
        }
        .animation(.easeOut(duration: 0.25), value: focused)
    }
}
//
//  DesignTokens.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//

import SwiftUI

public enum Tokens {
    
    // MARK: Colors (Figma -> SwiftUI)
    public enum Color {
        public static let accent = SwiftUI.Color("Accent")
        public static let accentPressed = SwiftUI.Color("AccentPressed")
        
        public static let textPrimary = SwiftUI.Color("TextPrimary")
        public static let textSecondary = SwiftUI.Color("TextSecondary")
        
        public static let borderNeutral = SwiftUI.Color("BorderNeutral")
        public static let backgroundMain = SwiftUI.Color("BackgroundMain")
        public static let shadowBlack7 = SwiftUI.Color("ShadowBlack7")
        public static let surfaceCard = SwiftUI.Color("SurfaceCard")
    }
    
    //MARK: Typography (SF Pro)
    public enum Font {
        public static let h1 = SwiftUI.Font.system(size:32, weight: .semibold)
        public static let h2 = SwiftUI.Font.system(size:28, weight: .medium)
        public static let title = SwiftUI.Font.system(size:22, weight: .medium)
        public static let subtitle = SwiftUI.Font.system(size:20, weight: .bold)
        public static let body = SwiftUI.Font.system(size:20, weight: .regular)
        public static let bodyMedium18 = SwiftUI.Font.system(size:18, weight: .medium)
        static let bodyMedium = SwiftUI.Font.system(size: 16, weight: .medium)
        public static let caption = SwiftUI.Font.system(size: 15, weight: .medium)
        public static let captionRegular = SwiftUI.Font.system(size: 15, weight: .regular)
    }
    
    //MARK: Spacing & Radius
    
    public enum Spacing {
        public static let x4:  CGFloat = 4
        public static let x8:  CGFloat = 8
        public static let x12: CGFloat = 12
        public static let x16: CGFloat = 16
        public static let x20: CGFloat = 20
        public static let x24: CGFloat = 24
        public static let x32: CGFloat = 32
    }
    
    public enum Radius {
        public static let pill:   CGFloat = 24
        public static let medium: CGFloat = 16
        public static let small:  CGFloat = 12
    }
    
    // MARK: Shadow
    public enum Shadow {
        public static let card = ShadowStyle(
            color: .black.opacity(0.07),
            radius: 12,
            y: 6
        )
    }
    
}

// MARK: Helpers
public struct ShadowStyle {
    public let color: Color
    public let radius: CGFloat
    public let y: CGFloat
}

public extension View {
    func apply(_ shadow: ShadowStyle) -> some View {
        self.shadow(color: shadow.color, radius: shadow.radius, x: 0, y: shadow.y)
    }
}
//
//  Corner+Helpers.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import SwiftUI

public extension View {
    @inlinable
    func cornerRadiusContinuous(_ r: CGFloat) -> some View {
        clipShape(RoundedRectangle(cornerRadius: r, style: .continuous))
    }

    @inlinable
    func roundedBorder(_ color: Color, lineWidth: CGFloat, radius: CGFloat) -> some View {
        overlay(
            RoundedRectangle(cornerRadius: radius, style: .continuous)
                .stroke(color, lineWidth: lineWidth)
        )
    }
}
//
//  Notification+Names.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//

import Foundation

/// Centralized notification names used across modules.
extension Notification.Name {
    /// Sent when the user saves a cheater analysis and taps “Open History”.
    static let openHistoryCheater = Notification.Name("openHistoryCheater")
}
//
//  Environment+Resolver.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import SwiftUI
import Swinject

private struct ResolverKey: EnvironmentKey {
    static let defaultValue: Resolver = Assembler([]).resolver
}

extension EnvironmentValues {
    var resolver: Resolver {
        get { self[ResolverKey.self]}
        set { self[ResolverKey.self] = newValue }
    }
}
//
//  DevSeed.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import Foundation
import Swinject

enum DevSeed {
    static func run(_ resolver: Resolver) {
        #if DEBUG
        guard let store = resolver.resolve(CheaterStore.self) else { return }
        if store.load().isEmpty {
            store.add(.init(
                kind: .image,
                riskScore: 80,
                note: "WhatsApp screenshot",
                redFlags: [],
                recommendations: []
            ))
            store.add(.init(
                kind: .file,
                riskScore: 92,
                note: "PDF contract",
                redFlags: [],
                recommendations: []
            ))
        }
        #endif
    }
}
//
//  AppAssembler.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Swinject

enum AppAssembler {
    static func make() -> Assembler {
        Assembler([
            ServicesAssembly()
        ])
    }
}
//
//  CheaterBusterApp.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//

import SwiftUI
import Swinject

@main
struct CheaterBusterApp: App {

    private let assembler = AppAssembler.make()
    private var resolver: Resolver { assembler.resolver }

    // получаем роутер из DI
    private var router: AppRouter { resolver.resolve(AppRouter.self)! }

    init() {
        DevSeed.run(resolver)
    }

    var body: some Scene {
        WindowGroup {
            RootTabView()
                .environment(\.resolver, resolver)
                .environmentObject(router)
        }
    }
}
//
//  AppRouter.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation
import Combine

/// Центральный роутер приложения.
/// Управляет выбранной вкладкой и предпочитаемым состоянием History.
final class AppRouter: ObservableObject {
    enum Tab: Hashable { case search, cheater, history, settings }

    /// Текущая активная вкладка.
    @Published var tab: Tab = .search

    /// Предпочтительный сегмент в History (чтобы открывался нужный по умолчанию).
    @Published var historyPreferredSegment: HistoryViewModel.Segment = .search

    /// Перейти на History → сразу на Cheater-сегмент.
    func openHistoryCheater() {
        historyPreferredSegment = .cheater
        tab = .history
    }

    /// Запомнить текущий выбранный сегмент History.
    func rememberHistorySegment(_ segment: HistoryViewModel.Segment) {
        historyPreferredSegment = segment
    }
}
//
//  Services+VMAssembly.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import Swinject

final class ServicesAssembly: Assembly {
    func assemble(container: Container) {

        // MARK: Infrastructure
        container.register(APIConfig.self) { _ in
            APIConfig(baseURL: URL(string: "https://cheaterbuster.webberapp.shop")!)
        }
        .inObjectScope(.container)

        container.register(TokenStorage.self) { _ in InMemoryTokenStorage() }
            .inObjectScope(.container)

        container.register(HTTPClient.self) { _ in URLSessionHTTPClient() }
            .inObjectScope(.container)

        // MARK: App router
        container.register(AppRouter.self) { _ in AppRouter() }
            .inObjectScope(.container)

        // MARK: Domain / Auth
        container.register(AuthRepository.self) { r in
            AuthRepositoryImpl(
                cfg: r.resolve(APIConfig.self)!,
                http: r.resolve(HTTPClient.self)!,
                tokens: r.resolve(TokenStorage.self)!
            )
        }
        .inObjectScope(.container)

        // MARK: Domain / API
        container.register(CheaterAPI.self) { r in
            CheaterAPIImpl(
                cfg: r.resolve(APIConfig.self)!,
                http: r.resolve(HTTPClient.self)!,
                tokens: r.resolve(TokenStorage.self)!
            )
        }
        .inObjectScope(.container)

        // MARK: Domain / Tasks
        container.register(TaskPoller.self) { r in
            TaskPollerImpl(api: r.resolve(CheaterAPI.self)!)
        }
        .inObjectScope(.container)

        // MARK: Domain Stores
        container.register(HistoryStore.self) { _ in HistoryStoreImpl() }
            .inObjectScope(.container)

        container.register(CheaterStore.self) { _ in CheaterStoreImpl() }
            .inObjectScope(.container)

        container.register(SettingsStore.self) { _ in SettingsStoreImpl() }
            .inObjectScope(.container)

        // MARK: - Added: Premium & Subscriptions
        container.register(PremiumStore.self) { _ in PremiumStoreImpl() }
            .inObjectScope(.container)

        container.register(SubscriptionService.self) { r in
            SubscriptionServiceStub(store: r.resolve(PremiumStore.self)!)
        }
        .inObjectScope(.container)

        // MARK: Domain / Search Repository (НОВОЕ ранее)
        container.register(SearchRepository.self) { r in
            SearchRepositoryImpl(api: r.resolve(CheaterAPI.self)!)
        }
        .inObjectScope(.container)

        // MARK: Services
        container.register(SearchService.self) { r in
            SearchServiceImpl(
                repo: r.resolve(SearchRepository.self)!,
                poller: r.resolve(TaskPoller.self)!
            )
        }
        .inObjectScope(.container)

        container.register(CheaterAnalyzerService.self) { _ in CheaterAnalyzerServiceImpl() }
            .inObjectScope(.container)

        // MARK: ViewModels
        container.register(SearchViewModel.self) { r in
            SearchViewModel(
                search: r.resolve(SearchService.self)!,
                history: r.resolve(HistoryStore.self)!,
                settings: r.resolve(SettingsStore.self)!
            )
        }

        container.register(HistoryViewModel.self) { r in
            HistoryViewModel(
                store: r.resolve(HistoryStore.self)!,
                cheaterStore: r.resolve(CheaterStore.self)!,
                search: r.resolve(SearchService.self)!
            )
        }

        container.register(CheaterViewModel.self) { r in
            CheaterViewModel(
                auth: r.resolve(AuthRepository.self)!,
                api: r.resolve(CheaterAPI.self)!,
                poller: r.resolve(TaskPoller.self)!,
                store: r.resolve(CheaterStore.self)!,
                cfg: r.resolve(APIConfig.self)!
            )
        }

        // Added: Settings VM
        container.register(SettingsViewModel.self) { r in
            SettingsViewModel(store: r.resolve(SettingsStore.self)!)
        }

        // Added: Paywall VM
        container.register(PaywallViewModel.self) { r in
            PaywallViewModel(subscription: r.resolve(SubscriptionService.self)!)
        }
       
        container.register(PermissionsManager.self) { _ in
            PermissionsManagerImpl()
        }.inObjectScope(.container)

    }
}
//
//  RootTabView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import SwiftUI
import Swinject
import StoreKit

struct RootTabView: View {
    @Environment(\.resolver) private var resolver
    @EnvironmentObject private var router: AppRouter

    @AppStorage("cb.hasOnboarded") private var hasOnboarded = false

    // раньше был отдельный стейт showOnboardingCover — больше не нужен
    @State private var didRunFirstFlow = false
    @State private var showRateUs = false
    @State private var showInitialPaywall = false

    var body: some View {
        TabView(selection: $router.tab) {
            SearchScreen(vm: resolver.resolve(SearchViewModel.self)!)
                .tabItem { Label("Search", systemImage: "magnifyingglass") }
                .tag(AppRouter.Tab.search)

            CheaterView(vm: resolver.resolve(CheaterViewModel.self)!)
                .tabItem { Label("Cheater", systemImage: "person.crop.circle.badge.exclamationmark") }
                .tag(AppRouter.Tab.cheater)

            HistoryView(vm: resolver.resolve(HistoryViewModel.self)!)
                .tabItem { Label("History", systemImage: "clock") }
                .tag(AppRouter.Tab.history)

            SettingsScreen(
                vm: SettingsViewModel(
                    store: resolver.resolve(SettingsStore.self)!
                )
            )
            .tabItem { Label("Settings", systemImage: "gearshape") }
            .tag(AppRouter.Tab.settings)
        }
        // MARK: - Fix: онбординг привязан напрямую к hasOnboarded
        .fullScreenCover(
            isPresented: Binding(
                get: { hasOnboarded == false },
                set: { presented in
                    // Если пользователь смахнул экран — считаем онбординг пройденным
                    if presented == false { hasOnboarded = true }
                }
            )
        ) {
            OnboardingView()
        }
        // кастомный Rate Us
        .sheet(isPresented: $showRateUs) {
            RateUsView(
                imageName: "rateus_hand",
                onLater: {
                    showRateUs = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.35) {
                        showInitialPaywall = true
                    }
                },
                onRated: {
                    showRateUs = false
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.35) {
                        showInitialPaywall = true
                    }
                }
            )
            .presentationDetents([.large])
        }
        // paywall
        .sheet(isPresented: $showInitialPaywall) {
            let vm = resolver.resolve(PaywallViewModel.self)!
            PaywallView(vm: vm)
                .presentationDetents([.large])
        }
        .onChange(of: hasOnboarded) { _, newValue in
            if newValue { triggerFirstRunFlowIfNeeded() }
        }
        .task {
            if hasOnboarded { triggerFirstRunFlowIfNeeded() }
        }
    }

    private func triggerFirstRunFlowIfNeeded() {
        guard didRunFirstFlow == false else { return }
        didRunFirstFlow = true

        let key = "cb.didShowRateThenPaywall.v1"
        guard UserDefaults.standard.bool(forKey: key) == false else { return }

        showRateUs = true
        UserDefaults.standard.set(true, forKey: key)
    }
}
//
//  PremiumStoreImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//


import Foundation

final class PremiumStoreImpl: PremiumStore {
    private let key = "cb.premium.v1"
    private let defaults: UserDefaults

    init(defaults: UserDefaults = .standard) {
        self.defaults = defaults
    }

    var isPremium: Bool {
        get {
            // дефолт — false
            (defaults.object(forKey: key) as? Bool) ?? false
        }
        set {
            defaults.set(newValue, forKey: key)
        }
    }
}
//
//  TokensStoreImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//


import Foundation

final class TokensStoreImpl: TokensStore {
    private let key = "cb.tokens.v1"
    private let defaults: UserDefaults

    init(defaults: UserDefaults = .standard) {
        self.defaults = defaults
    }

    var tokens: Int {
        get { defaults.object(forKey: key) as? Int ?? 0 }
        set { defaults.set(newValue, forKey: key) }
    }
}
//
//  SubscriptionServiceImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//


import Foundation

/// Реализация заглушки подписки для v1.
/// Сейчас: локальный флаг в UserDefaults. Далее заменим на Apphud SDK.
final class SubscriptionServiceImpl: SubscriptionService {
    private let defaults: UserDefaults
    private let key = "cb.subscribed.v1"

    private(set) var isSubscribed: Bool

    // MARK: - Init
    init(defaults: UserDefaults = .standard) {
        self.defaults = defaults
        self.isSubscribed = defaults.bool(forKey: key)
    }

    // MARK: - SubscriptionService

    @discardableResult
    func refreshStatus() async throws -> Bool {
        // V1: читаем локально. Позже — запрос в Apphud.
        isSubscribed = defaults.bool(forKey: key)
        return isSubscribed
    }

    @discardableResult
    func purchase(plan: SubscriptionPlan) async throws {
           // V1: план игнорируем, просто считаем покупку успешной.
           // (Позже здесь будет вызов Apphud/StoreKit2.)
           isSubscribed = true
           defaults.set(true, forKey: key)
       }

    @discardableResult
    func restore() async throws {
           // V1: читаем локальный флаг. Позже — Apphud.restore().
           isSubscribed = defaults.bool(forKey: key)
       }
    
    
}
//
//  SearchRepositoryImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation

/// Реализация SearchRepository через CheaterAPI.
final class SearchRepositoryImpl: SearchRepository {
    private let api: CheaterAPI

    init(api: CheaterAPI) {
        self.api = api
    }

    func createReverseSearch(image: Data, filename: String, mimeType: String) async throws -> UUID {
        let part = MultipartFormData.FilePart(
            name: "image",
            filename: filename,
            mimeType: mimeType,
            data: image
        )
        let created = try await api.createReverseSearch(image: part) // ReverseSearchCreateResponse
        return created.task_id
    }

    func getReverseSearch(taskId: UUID) async throws -> ReverseSearchGetResponse {
        try await api.getReverseSearch(id: taskId)
    }
}
//
//  SettingsStoreImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//

import Foundation

final class SettingsStoreImpl: SettingsStore {
    private let key = "isHistoryEnabled"

    // Хотим дефолт = true. bool(forKey:) даёт false, если ключ не записан.
    // Поэтому, если ключа нет — возвращаем true.
    var isHistoryEnabled: Bool {
        get {
            let defaults = UserDefaults.standard
            if defaults.object(forKey: key) == nil {
                return true
            }
            return defaults.bool(forKey: key)
        }
        set {
            UserDefaults.standard.set(newValue, forKey: key)
        }
    }
}
//
//  TaskPollerImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation

final class TaskPollerImpl: TaskPoller {
    private let api: CheaterAPI
    init(api: CheaterAPI) { self.api = api }

    func waitForAnalyzeResult(taskId: UUID, interval: TimeInterval = 1.0) async throws -> TaskReadDTO {
        while true {
            let state = try await api.getAnalyzeTask(id: taskId)
            switch state.status {
            case .finished, .failed: return state
            case .queued, .started, .other:
                try await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))
            }
        }
    }

    func waitForReverseResult(taskId: UUID, interval: TimeInterval = 1.0) async throws -> ReverseSearchGetResponse {
        while true {
            let r = try await api.getReverseSearch(id: taskId)
            // готово, когда все "completed"; любые другие (например "pending") — продолжаем
            let done = [r.status.google, r.status.yandex, r.status.bing]
                .allSatisfy { $0.lowercased() == "completed" }
            if done { return r }
            try await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))
        }
    }
}
//
//  SubscriptionServiceStub.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//



import Foundation

/// Заглушка до интеграции Apphud/StoreKit 2.
/// Успешно "покупает" или "восстанавливает" и включает premium.
final class SubscriptionServiceStub: SubscriptionService {

    private var store: PremiumStore

    init(store: PremiumStore) {
        self.store = store
    }

    func purchase(plan: SubscriptionPlan) async throws {
        // Микрозадержка, имитация сети
        try await Task.sleep(nanoseconds: 400_000_000)
        store.isPremium = true
    }

    func restore() async throws {
        try await Task.sleep(nanoseconds: 300_000_000)
        // В заглушке считаем, что покупки были — включаем premium
        store.isPremium = true
    }
}
//
//  AuthRepositoryImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation

final class AuthRepositoryImpl: AuthRepository {
    private let cfg: APIConfig
    private let http: HTTPClient
    private var tokens: TokenStorage

    init(cfg: APIConfig, http: HTTPClient, tokens: TokenStorage) {
        self.cfg = cfg; self.http = http; self.tokens = tokens
    }

    var isAuthorized: Bool { tokens.accessToken != nil }

    func ensureAuthorized(apphudId: String) async throws {
        if tokens.accessToken != nil { return }
        let createURL = cfg.baseURL.appendingPathComponent("/api/user")
        var r1 = URLRequest(url: createURL)
        r1.httpMethod = "POST"
        r1.setValue("application/json", forHTTPHeaderField: "Content-Type")
        r1.httpBody = try JSONEncoder().encode(CreateUserDTO(apphud_id: apphudId))
        let created: UserReadDTO = try await http.send(r1)
        tokens.userId = created.id.uuidString

        let authURL = cfg.baseURL.appendingPathComponent("/api/user/authorize")
        var r2 = URLRequest(url: authURL)
        r2.httpMethod = "POST"
        r2.setValue("application/json", forHTTPHeaderField: "Content-Type")
        r2.httpBody = try JSONEncoder().encode(AuthorizeUserDTO(user_id: created.id))
        let token: TokenResponseDTO = try await http.send(r2)
        tokens.accessToken = token.access_token
    }
}//
//  UserServiceImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//


//
//  UserServiceImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/30/25.
//

import Foundation

final class UserServiceImpl: UserService {
    private let cfg: APIConfig
    private let http: HTTPClient
    private let tokensStorage: TokenStorage
    private var tokensStore: TokensStore

    init(cfg: APIConfig,
         http: HTTPClient,
         tokensStorage: TokenStorage,
         tokensStore: TokensStore)
    {
        self.cfg = cfg
        self.http = http
        self.tokensStorage = tokensStorage
        self.tokensStore = tokensStore
    }

    func fetchMe() async throws -> UserReadDTO {
        let url = cfg.baseURL.appendingPathComponent("/api/user/me")
        var req = URLRequest(url: url)
        // MARK: - Added: auth header
        if let t = tokensStorage.accessToken {
            req.setValue("Bearer \(t)", forHTTPHeaderField: "Authorization")
        }
        let me: UserReadDTO = try await http.send(req)
        // Пишем баланс токенов в локальный стор (используем далее в UI/гейте)
        tokensStore.tokens = me.tokens
        return me
    }
}
//
//  HistoryStoreImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//

import Foundation
import UIKit

final class HistoryStoreImpl: HistoryStore {
    private let key = "cb.history.v1"
    private let limit = 10
    private let defaults: UserDefaults

    init(defaults: UserDefaults = .standard) {
        self.defaults = defaults
    }

    func load() -> [HistoryRecord] {
        guard let data = defaults.data(forKey: key) else { return [] }
        return (try? JSONDecoder().decode([HistoryRecord].self, from: data)) ?? []
    }

    func add(_ record: HistoryRecord) {
        var arr = load()

        // глобальная де-дупликация:
        if let q = record.query {
            arr.removeAll { $0.kind == .name && $0.query == q }
        } else if let data = record.imageJPEG {
            let h = data.hashValue
            arr.removeAll { $0.kind == .face && ($0.imageJPEG?.hashValue == h) }
        }

        arr.insert(record, at: 0)
        if arr.count > limit {
            arr = Array(arr.prefix(limit))
        }
        save(arr)
    }

    func clearAll() {
        defaults.removeObject(forKey: key)
    }

    private func save(_ arr: [HistoryRecord]) {
        if let data = try? JSONEncoder().encode(arr) {
            defaults.set(data, forKey: key)
        }
    }
}
//
//  CheaterAnalyzerServiceImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import Combine

final class CheaterAnalyzerServiceImpl: CheaterAnalyzerService {
    func analyze(text: String) -> AnyPublisher<ConversationAnalysis, Error> {
        let score = min(100, max(0, text.count % 100))
        let mock = ConversationAnalysis(
            riskScore: score,
            redFlags: ["Asks to move off-platform", "Urgency for payment"],
            recomendations: ["Ask for a short video call", "Don’t prepay"]
        )
        return  Just(mock)
            .delay(for: .milliseconds(400), scheduler: DispatchQueue.main)
            .setFailureType(to: Error.self)
            .eraseToAnyPublisher()
    }
    
}
//
//  CheaterStoreImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//



import Foundation

final class CheaterStoreImpl: CheaterStore {
    private let key = "cb.cheater.history.v1"
    private let limit = 10
    private let defaults: UserDefaults

    init(defaults: UserDefaults = .standard) { self.defaults = defaults }

    func load() -> [CheaterRecord] {
        guard let data = defaults.data(forKey: key) else { return [] }
        return (try? JSONDecoder().decode([CheaterRecord].self, from: data)) ?? []
    }

    func add(_ record: CheaterRecord) {
        var arr = load()

        // Простая де-дупликация по (kind, riskScore, note)
        arr.removeAll { $0.kind == record.kind &&
                        $0.riskScore == record.riskScore &&
                        ($0.note ?? "") == (record.note ?? "") }

        arr.insert(record, at: 0)
        if arr.count > limit { arr = Array(arr.prefix(limit)) }
        save(arr)
    }

    func clearAll() {
        defaults.removeObject(forKey: key)
    }

    private func save(_ arr: [CheaterRecord]) {
        if let data = try? JSONEncoder().encode(arr) {
            defaults.set(data, forKey: key)
        }
    }
}
//
//  SearchServiceImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import Combine


/// Высокоуровневый сервис поиска.
/// Работает через SearchRepository (низкий уровень) и TaskPoller (поллинг).
final class SearchServiceImpl: SearchService {
    private let repo: SearchRepository
    private let poller: TaskPoller

    init(repo: SearchRepository, poller: TaskPoller) {
        self.repo = repo
        self.poller = poller
    }

    // Поиск по имени — пока мок (E9-2 подключим реальный API при необходимости).
    func searchByName(_ query: String) -> AnyPublisher<[ImageHit], Error> {
        Just(query)
            .delay(for: .milliseconds(300), scheduler: DispatchQueue.main)
            .tryMap { q in
                let trimmed = q.trimmingCharacters(in: .whitespacesAndNewlines)
                guard !trimmed.isEmpty else { return [] }
                return (0..<6).map { i in
                    ImageHit(
                        title: "Result \(i+1) for '\(trimmed)'",
                        source: "example.com",
                        thumbnailURL: URL(string: "https://picsum.photos/seed/\(trimmed)\(i)/400/300"),
                        linkURL: URL(string: "https://example.com/\(i)")
                    )
                }
            }
            .eraseToAnyPublisher()
    }

    // Реальный reverse image search по фото.
    func searchByImage(_ jpegData: Data) -> AnyPublisher<[ImageHit], Error> {
        Future { [repo, poller] promise in
            Task {
                do {
                    // 1) создать задачу
                    let taskId = try await repo.createReverseSearch(
                        image: jpegData,
                        filename: "image.jpg",
                        mimeType: "image/jpeg"
                    )

                    // 2) дождаться готовности всех провайдеров (google/yandex/bing)
                    let resp = try await poller.waitForReverseResult(taskId: taskId, interval: 1.0)

                    // 3) маппинг в UI-модель
                    let hits = Self.mapReverseResponseToHits(resp)
                    promise(.success(hits))
                } catch {
                    promise(.failure(error))
                }
            }
        }
        .eraseToAnyPublisher()
    }

    // MARK: - Mapping

    private static func mapReverseResponseToHits(_ resp: ReverseSearchGetResponse) -> [ImageHit] {
        // Берём google.visual_matches; при желании можно объединить с yandex/bing.
        guard let g = resp.results.google,
              let matches = g.visual_matches, !matches.isEmpty
        else { return [] }

        return matches.compactMap { vm in
            ImageHit(
                title: vm.title,
                source: vm.source,
                thumbnailURL: vm.thumbnail.flatMap(URL.init(string:)),
                linkURL: URL(string: vm.link)
            )
        }
    }
}
//
//  CheaterAPIImpl.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


// Data/Services/API/CheaterAPIImpl.swift
import Foundation

final class CheaterAPIImpl: CheaterAPI {
    private let cfg: APIConfig
    private let http: HTTPClient
    private let tokens: TokenStorage

    init(cfg: APIConfig, http: HTTPClient, tokens: TokenStorage) {
        self.cfg = cfg; self.http = http; self.tokens = tokens
    }

    private func authed(_ req: inout URLRequest) {
        if let t = tokens.accessToken {
            req.setValue("Bearer \(t)", forHTTPHeaderField: "Authorization")
        }
    }

    // MARK: - /api/task (files[], conversation?, app_bundle*, webhook_url?)
    func createAnalyzeTask(
        files: [MultipartFormData.FilePart],
        conversation: String?
    ) async throws -> TaskReadDTO {
        let url = cfg.baseURL.appendingPathComponent("/api/task")
        var req = URLRequest(url: url); req.httpMethod = "POST"
        authed(&req)

        let mp = MultipartFormData()
        let body = mp.build(fields: [
            "conversation": conversation,
            "app_bundle": cfg.bundleId,
            "webhook_url": nil
        ], files: files.map { part in
            // поле должно называться "files" (массив), даже если один файл
            MultipartFormData.FilePart(
                name: "files",
                filename: part.filename,
                mimeType: part.mimeType,
                data: part.data
            )
        })
        req.setValue(mp.contentType, forHTTPHeaderField: "Content-Type")
        req.httpBody = body
        return try await http.send(req)
    }

    // MARK: - /api/task/place (file, conversation?, app_bundle*, webhook_url?)
    func createAnalyzePlaceTask(
        file: MultipartFormData.FilePart,
        conversation: String?
    ) async throws -> TaskReadDTO {
        let url = cfg.baseURL.appendingPathComponent("/api/task/place")
        var req = URLRequest(url: url); req.httpMethod = "POST"
        authed(&req)

        let mp = MultipartFormData()
        // строго одно поле "file"
        let one = MultipartFormData.FilePart(
            name: "file",
            filename: file.filename,
            mimeType: file.mimeType,
            data: file.data
        )
        let body = mp.build(fields: [
            "conversation": conversation,
            "app_bundle": cfg.bundleId,
            "webhook_url": nil
        ], files: [one])
        req.setValue(mp.contentType, forHTTPHeaderField: "Content-Type")
        req.httpBody = body
        return try await http.send(req)
    }

    func getAnalyzeTask(id: UUID) async throws -> TaskReadDTO {
        let url = cfg.baseURL.appendingPathComponent("/api/task/\(id.uuidString)")
        var req = URLRequest(url: url)
        authed(&req)
        return try await http.send(req)
    }

    // MARK: - Reverse search (без изменений в контракте)
    func createReverseSearch(image: MultipartFormData.FilePart) async throws -> ReverseSearchCreateResponse {
        let url = cfg.baseURL.appendingPathComponent("/api/search")
        var req = URLRequest(url: url); req.httpMethod = "POST"
        authed(&req)
        let mp = MultipartFormData()
        let body = mp.build(fields: [:], files: [
            MultipartFormData.FilePart(
                name: "image",
                filename: image.filename,
                mimeType: image.mimeType,
                data: image.data
            )
        ])
        req.setValue(mp.contentType, forHTTPHeaderField: "Content-Type")
        req.httpBody = body
        return try await http.send(req)
    }

    func getReverseSearch(id: UUID) async throws -> ReverseSearchGetResponse {
        let url = cfg.baseURL.appendingPathComponent("/api/search/\(id.uuidString)")
        var req = URLRequest(url: url)
        authed(&req)
        return try await http.send(req)
    }
}
//
//  TokensStore.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//


import Foundation

public protocol TokensStore {
    var tokens: Int { get set }
}
//
//  PremiumStore.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//

import Foundation

public protocol PremiumStore {
    /// Флаг подписки. В первой итерации — просто boolean.
    var isPremium: Bool { get set }
}
//
//  PermissionsManager.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//




import Foundation

public protocol PermissionsManager {
    func status(of permission: Permission) async -> PermissionStatus
    func request(_ permission: Permission) async -> PermissionStatus
}

public enum Permission: Sendable {
    case tracking
    case notifications
    case photoLibrary
    case camera
    case files // документ-пикер (на iOS отдельного пермишна нет, см. реализацию)
}

public enum PermissionStatus: Equatable, Sendable {
    case authorized
    case denied
    case notDetermined
    case restricted
    case temporarilyUnavailable  // сеть/система не готова
    case unsupported             // платформа не поддерживает
}
//
//  TaskPoller.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//



// Domain/UseCases/TaskPoller.swift
import Foundation

protocol TaskPoller {
    func waitForAnalyzeResult(taskId: UUID, interval: TimeInterval) async throws -> TaskReadDTO
    func waitForReverseResult(taskId: UUID, interval: TimeInterval) async throws -> ReverseSearchGetResponse
}

//
//  AuthRepository.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation

protocol AuthRepository {
    func ensureAuthorized(apphudId: String) async throws
    var isAuthorized: Bool { get }
}

//
//  TokenStorage.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//

import Foundation

protocol TokenStorage {
    var accessToken: String? { get set }
    var userId: String? { get set }
}

//
//  APIError.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//



import Foundation

enum APIError: Error {
    case invalidURL
    case http(Int, String?)         // status code + server body
    case decoding(Error)
    case transport(Error)
    case noData
    case unauthorized
}

extension APIError: LocalizedError {
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid URL."
        case .http(let code, let body):
            let trimmed = body?
                .replacingOccurrences(of: "\r", with: "")
                .replacingOccurrences(of: "\n", with: " ")
                .prefix(500) ?? ""
            return "HTTP \(code). \(trimmed)"
        case .decoding(let err):
            return "Decoding error: \(err.localizedDescription)"
        case .transport(let err):
            return "Network error: \(err.localizedDescription)"
        case .noData:
            return "Empty response."
        case .unauthorized:
            return "Unauthorized (401)."
        }
    }
}
//
//  HTTPClient.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation

public protocol HTTPClient {
    func send<T: Decodable>(_ request: URLRequest) async throws -> T
    func sendVoid(_ request: URLRequest) async throws
}

//
//  CheaterAnalyzerService.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import Combine

public protocol CheaterAnalyzerService {
    func analyze(text: String) -> AnyPublisher<ConversationAnalysis,Error>
}
 
//
//  CheaterStore.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import Foundation

protocol CheaterStore {
    func load() -> [CheaterRecord]
    func add(_ record: CheaterRecord)
    func clearAll()
}
//
//  CheaterAPI.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation

protocol CheaterAPI {
    // Анализ переписки/изображения
    func createAnalyzeTask(
        files: [MultipartFormData.FilePart],
        conversation: String?
    ) async throws -> TaskReadDTO

    // Поиск по месту (endpoint /api/task/place — важна форма "file")
    func createAnalyzePlaceTask(
        file: MultipartFormData.FilePart,
        conversation: String?
    ) async throws -> TaskReadDTO

    func getAnalyzeTask(id: UUID) async throws -> TaskReadDTO

    // Реверс-поиск изображений
    func createReverseSearch(image: MultipartFormData.FilePart) async throws -> ReverseSearchCreateResponse
    func getReverseSearch(id: UUID) async throws -> ReverseSearchGetResponse
}
//
//  SearchService.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Combine
import Foundation

public protocol SearchService {
    func searchByName(_ query: String) -> AnyPublisher<[ImageHit], Error>
    func searchByImage(_ jpegData: Data) -> AnyPublisher<[ImageHit],Error>
}
//
//  HistoryStore.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import Combine

public protocol HistoryStore {
    func load() -> [HistoryRecord]
    func add(_ record: HistoryRecord)
    func clearAll()
}
//
//  SettingsStore.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation

public protocol SettingsStore {
    var isHistoryEnabled: Bool { get set }
}
//
//  UserService.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//


import Foundation

 protocol UserService {
    /// Читает профиль пользователя с бэкенда.
    func fetchMe() async throws -> UserReadDTO
}
//
//  SubscriptionPlan.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//


import Foundation

public enum SubscriptionPlan: Equatable {
    case monthly
    case yearly
}

public protocol SubscriptionService {
    /// Покупка выбранного плана (заглушка Apphud на D2).
    func purchase(plan: SubscriptionPlan) async throws

    /// Восстановление покупок.
    func restore() async throws
}
//
//  SearchRepository.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//




import Foundation

/// Низкоуровневый доступ к reverse image search API.
/// Репозиторий ничего не знает о Combine/SwiftUI и не занимается поллингом.
protocol SearchRepository {
    /// Создать задачу reverse-search и вернуть её id.
    func createReverseSearch(image: Data, filename: String, mimeType: String) async throws -> UUID

    /// Получить состояние/результат по taskId.
    func getReverseSearch(taskId: UUID) async throws -> ReverseSearchGetResponse
}
//
//  TaskDTO.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation

// Статусы по докам: queued | started | failed | finished.
// Поддержим "completed"/"running" как синонимы на всякий случай (бэк может дрейфовать).
enum TaskStatus: Equatable {
    case queued
    case started
    case failed
    case finished
    case other(String)
}

extension TaskStatus: Codable {
    init(from decoder: Decoder) throws {
        let raw = try decoder.singleValueContainer().decode(String.self).lowercased()
        switch raw {
        case "queued":      self = .queued
        case "started",
             "running":     self = .started
        case "finished",
             "completed":   self = .finished
        case "failed":      self = .failed
        default:            self = .other(raw)
        }
    }
    func encode(to encoder: Encoder) throws {
        var c = encoder.singleValueContainer()
        switch self {
        case .queued:       try c.encode("queued")
        case .started:      try c.encode("started")
        case .failed:       try c.encode("failed")
        case .finished:     try c.encode("finished")
        case .other(let s): try c.encode(s)
        }
    }
}

struct TaskResult: Codable, Equatable {
    let risk_score: Int
    let red_flags: [String]
    let recommendations: [String]
}

// Поле result может быть: объект | строка | null. Делаем сумм-тип.
enum TaskReadResult: Equatable {
    case details(TaskResult)
    case message(String)
    case none
}

extension TaskReadResult: Codable {
    init(from decoder: Decoder) throws {
        let c = try decoder.singleValueContainer()
        // Попробуем объект
        if let obj = try? c.decode(TaskResult.self) { self = .details(obj); return }
        // Попробуем строку
        if let msg = try? c.decode(String.self) { self = .message(msg); return }
        // Иначе null / неизвестно
        self = .none
    }
    func encode(to encoder: Encoder) throws {
        var c = encoder.singleValueContainer()
        switch self {
        case .details(let d): try c.encode(d)
        case .message(let s): try c.encode(s)
        case .none:          try c.encodeNil()
        }
    }
}

struct TaskReadDTO: Codable, Equatable {
    let id: UUID
    let status: TaskStatus
    let result: TaskReadResult?
    let error: String?
}
//
//  UserReadDTO.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//



import Foundation

struct UserReadDTO: Codable {
    let id: UUID
    let apphud_id: String
    let tokens: Int
}

struct CreateUserDTO: Codable { let apphud_id: String }
struct AuthorizeUserDTO: Codable { let user_id: UUID }
struct TokenResponseDTO: Codable { let access_token: String; let token_type: String }
//
//  TaskCreateResponse.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation

struct TaskCreateResponse: Codable {
    let task_id: UUID
}
//
//  ReverseSearchDTO.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import Foundation

struct ReverseSearchCreateResponse: Codable { let task_id: UUID }

struct ReverseSearchGetResponse: Codable {
    struct EnginesStatus: Codable { let google: String; let yandex: String; let bing: String }
    struct Google: Codable {
        struct VisualMatch: Codable {
            let position: Int
            let title: String
            let link: String
            let source: String
            let thumbnail: String?
        }
        let visual_matches: [VisualMatch]?
    }
    let status: EnginesStatus
    let results: Results
    struct Results: Codable {
        let google: Google?
        // yandex/bing можно добавить при необходимости UI
    }
}
//
//  HistoryKind.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import Foundation
import UIKit

public enum HistoryKind: String, Codable {
    case name   
    case face
}

public struct HistoryRecord: Identifiable, Codable {
    public let id: UUID
    public let createdAt: Date
    public let kind: HistoryKind

    
    public let query : String?

    
    public let imageJPEG: Data?

    
    public let titlePreview: String?
    public let sourcePreview: String?

    public init(id: UUID = UUID(),
                createdAt: Date = .init(),
                kind: HistoryKind,
                query: String? = nil,
                imageJPEG: Data? = nil,
                titlePreview: String? = nil,
                sourcePreview: String? = nil) {
        self.id = id
        self.createdAt = createdAt
        self.kind = kind
        self.query = query
        self.imageJPEG = imageJPEG
        self.titlePreview = titlePreview
        self.sourcePreview = sourcePreview
    }
}
//
//  ConversationAnalysis.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation

public struct ConversationAnalysis: Equatable {
    public let riskScore: Int
    public let redFlags: [String]
    public let recomendations: [String]
    
    init(riskScore: Int, redFlags: [String], recomendations: [String]) {
        self.riskScore = riskScore
        self.redFlags = redFlags
        self.recomendations = recomendations
    }
}
//
//  ImageHit.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation

public struct ImageHit: Identifiable, Hashable {
    public let id: UUID = UUID()
    public let title: String
    public let source: String
    public let thumbnailURL: URL?
    public let linkURL: URL?
    
    public init(title: String, source: String, thumbnailURL: URL?, linkURL: URL?) {
        self.title = title
        self.source = source
        self.thumbnailURL = thumbnailURL
        self.linkURL = linkURL
    }
}
//
//  CheaterRecord.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//



import Foundation

public struct CheaterRecord: Identifiable, Hashable, Codable {
    public enum Kind: String, Codable { case image, file, text }

    public let id: UUID
    public let date: Date
    public let kind: Kind
    public let riskScore: Int
    public let note: String?
    public let redFlags: [String]
    public let recommendations: [String]

    public init(
        id: UUID = UUID(),
        date: Date = Date(),
        kind: Kind,
        riskScore: Int,
        note: String? = nil,
        redFlags: [String],
        recommendations: [String]
    ) {
        self.id = id
        self.date = date
        self.kind = kind
        self.riskScore = riskScore
        self.note = note
        self.redFlags = redFlags
        self.recommendations = recommendations
    }

    // Hashable/Equatable — только по id (удобно для навигации/списков)
    public static func == (lhs: CheaterRecord, rhs: CheaterRecord) -> Bool { lhs.id == rhs.id }
    public func hash(into hasher: inout Hasher) { hasher.combine(id) }
}
//
//  SettingsScreen.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import SwiftUI
import Swinject
import StoreKit // MARK: - Added

struct SettingsScreen: View {
    @StateObject private var vm: SettingsViewModel

    @Environment(\.resolver) private var resolver
    @State private var showPaywall = false

    // MARK: - Added (константы)
    private let supportEmail = "support@cheaterbuster.app"
    private let termsURL = URL(string: "https://cheaterbuster.app/terms")!
    private let privacyURL = URL(string: "https://cheaterbuster.app/privacy")!
    private let shareText = "Cheater Buster — check profiles and chats: https://cheaterbuster.app"

    // MARK: - Added (share sheet)
    @State private var showShareSheet = false

    init(vm: SettingsViewModel) {
        _vm = StateObject(wrappedValue: vm)
    }

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: Tokens.Spacing.x24) {

                    // Блок Premium
                    groupCard {
                        navRow(
                            system: "chart.bar.doc.horizontal.fill",
                            tint: Tokens.Color.accent,
                            title: "Get a premium"
                        ) {
                            showPaywall = true
                        }

                        Divider().padding(.leading, 52)

                        navRow(
                            system: "arrow.clockwise.circle.fill",
                            tint: Tokens.Color.accent,
                            title: "Restore purchases"
                        ) {
                            // Восстановление доступно на Paywall — оставляем текущий поток (не меняем контракты)
                            showPaywall = true
                        }
                    }

                    // Блок Info
                    groupCard {
                        navRow(system: "bubble.left.and.bubble.right.fill",
                               tint: Tokens.Color.accent,
                               title: "Support") {
                            openSupport()
                        }

                        Divider().padding(.leading, 52)

                        navRow(system: "doc.text.fill",
                               tint: Tokens.Color.accent,
                               title: "Terms of Use") {
                            openURL(termsURL)
                        }

                        Divider().padding(.leading, 52)

                        navRow(system: "shield.fill",
                               tint: Tokens.Color.accent,
                               title: "Privacy Policy") {
                            openURL(privacyURL)
                        }
                    }

                    // Блок Rate/Share
                    groupCard {
                        navRow(system: "star.fill",
                               tint: Tokens.Color.accent,
                               title: "Rate Us") {
                            SKStoreReviewController.requestReview()
                        }

                        Divider().padding(.leading, 52)

                        navRow(system: "square.and.arrow.up.fill",
                               tint: Tokens.Color.accent,
                               title: "Share with friends") {
                            showShareSheet = true
                        }
                    }

                    // Опция «Save history»
                    groupCard {
                        HStack(spacing: Tokens.Spacing.x12) {
                            Image(systemName: "clock.arrow.circlepath")
                                .foregroundStyle(Tokens.Color.accent)
                                .frame(width: 28, height: 28)
                            Toggle("Save history", isOn: $vm.isHistoryEnabled)
                                .tint(Tokens.Color.accent)
                        }
                        .padding(.horizontal, Tokens.Spacing.x12)
                        .padding(.vertical, Tokens.Spacing.x12)
                    }
                }
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.top, Tokens.Spacing.x16)
            }
            .background(Tokens.Color.backgroundMain.ignoresSafeArea())
            .navigationTitle("Settings")
        }
        .sheet(isPresented: $showPaywall) {
            // Resolve VM из DI при показе
            let paywallVM = resolver.resolve(PaywallViewModel.self)!
            PaywallView(vm: paywallVM)
                .presentationDetents([.large])
        }
        // MARK: - Added: Share sheet
        .sheet(isPresented: $showShareSheet) {
            ActivityView(activityItems: [shareText])
        }
    }

    // MARK: - UI helpers

    @ViewBuilder
    private func groupCard<Content: View>(@ViewBuilder _ content: () -> Content) -> some View {
        VStack(spacing: 0) {
            content()
        }
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(Tokens.Color.surfaceCard)
        )
        .apply(Tokens.Shadow.card)
    }

    private func navRow(system: String, tint: Color, title: String, action: @escaping () -> Void) -> some View {
        Button(action: action) {
            HStack(spacing: Tokens.Spacing.x12) {
                Image(systemName: system)
                    .foregroundStyle(tint)
                    .frame(width: 28, height: 28)

                Text(title)
                    .font(Tokens.Font.body)
                    .foregroundStyle(Tokens.Color.textPrimary)

                Spacer()

                Image(systemName: "chevron.right")
                    .foregroundStyle(Tokens.Color.textSecondary.opacity(0.8))
            }
            .padding(.horizontal, Tokens.Spacing.x12)
            .padding(.vertical, Tokens.Spacing.x12)
        }
        .buttonStyle(.plain)
    }

    // MARK: - Added: helpers

    private func openURL(_ url: URL) {
        UIApplication.shared.open(url, options: [:], completionHandler: nil)
    }

    private func openSupport() {
        // Пытаемся mailto:, при неудаче — откроем сайт поддержки
        let mailto = URL(string: "mailto:\(supportEmail)")!
        if UIApplication.shared.canOpenURL(mailto) {
            UIApplication.shared.open(mailto, options: [:], completionHandler: nil)
        } else {
            openURL(URL(string: "https://cheaterbuster.app/support")!)
        }
    }
}

// MARK: - Added: UIKit activity wrapper (внутри файла, чтобы не плодить слоёв)
private struct ActivityView: UIViewControllerRepresentable {
    let activityItems: [Any]
    func makeUIViewController(context: Context) -> UIActivityViewController {
        UIActivityViewController(activityItems: activityItems, applicationActivities: nil)
    }
    func updateUIViewController(_ vc: UIActivityViewController, context: Context) {}
}
//
//  SettingsViewModel.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//

import Foundation
import Combine

final class SettingsViewModel: ObservableObject {
    @Published var isHistoryEnabled: Bool {
        didSet { store.isHistoryEnabled = isHistoryEnabled }
    }

    private var store: SettingsStore

    init(store: SettingsStore) {
        self.store = store
        self.isHistoryEnabled = store.isHistoryEnabled
    }
}
//
//  SearchViewModel.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import Foundation
import Combine
import UIKit

final class SearchViewModel: ObservableObject {

    // MARK: - Input
    @Published var query: String = ""

    // MARK: - Output
    @Published private(set) var results: [ImageHit] = []
    @Published private(set) var isLoading: Bool = false            // мелкие индикаторы (в кнопках)
    @Published private(set) var isBlockingLoading: Bool = false     // full-screen загрузка
    @Published private(set) var errorText: String?

    // MARK: - Deps
    private let search: SearchService
    private let history: HistoryStore
    // settings можно использовать позже (флаги, лимиты, т.п.)
    private let settings: SettingsStore?

    private var bag = Set<AnyCancellable>()

    // MARK: - Init
    init(search: SearchService,
         history: HistoryStore,
         settings: SettingsStore? = nil)
    {
        self.search = search
        self.history = history
        self.settings = settings
        bindQueryDebounce()
    }

    // MARK: - Debounce по вводу (без блокирующей загрузки)
    private func bindQueryDebounce() {
        $query
            .removeDuplicates()
            .debounce(for: .milliseconds(300), scheduler: DispatchQueue.main)
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            .flatMap { [weak self] q -> AnyPublisher<[ImageHit], Never> in
                guard let self, !q.isEmpty else { return Just([]).eraseToAnyPublisher() }
                
                return self.search.searchByName(q)
                    .map { $0 }
                    .catch { [weak self] err -> AnyPublisher<[ImageHit], Never> in
                        self?.errorText = err.localizedDescription
                        return Just([]).eraseToAnyPublisher()
                    }
                    .eraseToAnyPublisher()
            }
            .receive(on: DispatchQueue.main)
            .assign(to: &$results)
    }

    // MARK: - Явный запуск по кнопке «Find»
    func runNameSearch() {
        let q = query.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !q.isEmpty else { return }

        isLoading = true
        isBlockingLoading = true
        errorText = nil

        search.searchByName(q)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                guard let self else { return }
                self.isLoading = false
                self.isBlockingLoading = false
                if case .failure(let err) = completion {
                    self.errorText = err.localizedDescription
                    self.results = []
                }
            } receiveValue: { [weak self] hits in
                guard let self else { return }
                self.results = hits

                
                let previewTitle  = hits.first?.title
                let previewSource = hits.first?.source
                let rec = HistoryRecord(
                    kind: .name,
                    query: q,
                    imageJPEG: nil,
                    titlePreview: previewTitle,
                    sourcePreview: previewSource
                )
                self.history.add(rec)
            }
            .store(in: &bag)
    }

    // MARK: - Запуск по кнопке «Analyze» (по фото)
    func runImageSearch(jpegData: Data) {
        isLoading = true
        isBlockingLoading = true
        errorText = nil

        search.searchByImage(jpegData)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                guard let self else { return }
                self.isLoading = false
                self.isBlockingLoading = false
                if case .failure(let err) = completion {
                    self.errorText = err.localizedDescription
                    self.results = []
                }
            } receiveValue: { [weak self] hits in
                guard let self else { return }
                self.results = hits

                
                let thumbData = (UIImage(data: jpegData)?
                    .jpegData(compressionQuality: 0.5)) ?? jpegData

                let rec = HistoryRecord(
                    kind: .face,
                    query: nil,
                    imageJPEG: thumbData,
                    titlePreview: hits.first?.title,
                    sourcePreview: hits.first?.source
                )
                self.history.add(rec)
            }
            .store(in: &bag)
    }

    // MARK: - Прочее (если нужно использовать)
    func resetResults() {
        results = []
        errorText = nil
    }
}
//
//  FaceSearchView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/27/25.
//

import SwiftUI
import PhotosUI
import UIKit
import Swinject // MARK: - Added

struct FaceSearchView: View {
    @ObservedObject var vm: SearchViewModel
    @Environment(\.dismiss) private var dismiss
    @Environment(\.resolver) private var resolver // MARK: - Added

    @State private var item: PhotosPickerItem?
    @State private var image: UIImage?

    @State private var goResults = false
    @State private var didAnalyze = false
    @State private var showPaywall = false // MARK: - Added

    var body: some View {
        ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            VStack(spacing: Tokens.Spacing.x16) {
                // Header
                HStack {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "arrow.left")
                            .font(.system(size: 16, weight: .semibold))
                            .foregroundStyle(Tokens.Color.textPrimary)
                            .padding(12)
                            .background(
                                Tokens.Color.surfaceCard,
                                in: RoundedRectangle(cornerRadius: 16, style: .continuous)
                            )
                            .apply(Tokens.Shadow.card)
                    }

                    Spacer()

                    Text("Face search")
                        .font(Tokens.Font.title)
                        .foregroundStyle(Tokens.Color.textPrimary)

                    Spacer().frame(width: 44)
                }
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.top, Tokens.Spacing.x16)

                // Preview
                Group {
                    if let img = image {
                        Image(uiImage: img)
                            .resizable()
                            .scaledToFit()
                            .frame(maxWidth: .infinity)
                            .padding(.horizontal, Tokens.Spacing.x16)
                            .padding(.top, Tokens.Spacing.x12)
                            .clipShape(RoundedRectangle(cornerRadius: 22, style: .continuous))
                            .overlay(
                                RoundedRectangle(cornerRadius: 22, style: .continuous)
                                    .stroke(Tokens.Color.borderNeutral, lineWidth: 1)
                            )
                    } else {
                        ContentUnavailableView(
                            "Select a photo",
                            systemImage: "photo",
                            description: Text("Pick one image to search by face.")
                        )
                        .padding(.horizontal, Tokens.Spacing.x16)
                        .padding(.top, Tokens.Spacing.x32)
                    }
                }

                Spacer(minLength: 0)
            }
        }
        .navigationBarBackButtonHidden(true)

        // Bottom tools panel
        .safeAreaInset(edge: .bottom) {
            HStack(spacing: Tokens.Spacing.x16) {
                CircleTool(system: "rotate.left")  { /* позже */ }
                CircleTool(system: "rotate.right") { /* позже */ }
                CircleTool(system: "crop")         { /* позже */ }

                Spacer()

                // Pink CTA →
                Button {
                    guard let img = image,
                          let jpeg = img.jpegData(compressionQuality: 0.85) else { return }
                    // MARK: - Added (premium gate)
                    let isPremium = (resolver.resolve(PremiumStore.self)?.isPremium ?? false)
                    guard isPremium else {
                        showPaywall = true
                        return
                    }
                    didAnalyze = true
                    vm.runImageSearch(jpegData: jpeg)
                } label: {
                    Image(systemName: "arrow.right")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundStyle(.white)
                        .frame(width: 52, height: 52)
                        .background(
                            Tokens.Color.accent,
                            in: Circle()
                        )
                        .shadow(color: .black.opacity(0.12), radius: 8, y: 4)
                }
                .buttonStyle(.plain)
                .disabled(image == nil || vm.isLoading)
            }
            .padding(.horizontal, Tokens.Spacing.x20)
            .padding(.vertical, Tokens.Spacing.x16)
            .background(
                Tokens.Color.surfaceCard,
                ignoresSafeAreaEdges: .bottom
            )
        }

        // Photos picker
        .photosPicker(isPresented: Binding(
            get: { image == nil && item == nil }, set: { _ in }
        ), selection: $item, matching: .images)

        .onChange(of: item) { _, newValue in
            Task { @MainActor in
                guard let data = try? await newValue?.loadTransferable(type: Data.self),
                      let img = UIImage(data: data) else { return }
                image = img
            }
        }

        // Навигация к результатам
        .onChange(of: vm.isLoading) { was, isNow in
            if didAnalyze && was == true && isNow == false {
                didAnalyze = false
                goResults = true
            }
        }
        .navigationDestination(isPresented: $goResults) {
            SearchResultsView(results: vm.results, mode: .face)
        }

        // Блокирующая "загрузка"
        .fullScreenCover(
            isPresented: Binding(
                get: { vm.isBlockingLoading },
                set: { _ in }
            )
        ) {
            LoadingView(mode: .face, previewImage: image, cancelAction: nil)
                .interactiveDismissDisabled(true)
        }

        // MARK: - Added Paywall
        .sheet(isPresented: $showPaywall) {
            let paywallVM = resolver.resolve(PaywallViewModel.self)!
            PaywallView(vm: paywallVM)
                .presentationDetents([.large])
        }
    }
}

private struct CircleTool: View {
    let system: String
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            Image(systemName: system)
                .font(.system(size: 16, weight: .semibold))
                .foregroundStyle(Tokens.Color.textPrimary)
                .frame(width: 48, height: 48)
                .background(
                    Tokens.Color.backgroundMain,
                    in: Circle()
                )
                .shadow(color: .black.opacity(0.08), radius: 10, y: 4)
        }
        .buttonStyle(.plain)
    }
}
//  SearchScreen.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import SwiftUI

struct SearchScreen: View {
    // MARK: - Removed: goName (больше не нужен)
    @State private var goPhoto = false
    private let vm: SearchViewModel

    init(vm: SearchViewModel) { self.vm = vm }

    var body: some View {
        NavigationStack {
            VStack(spacing: Tokens.Spacing.x16) {
                Text("Find your partner")
                    .font(Tokens.Font.h2)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(.top, Tokens.Spacing.x8)

                VStack(spacing: Tokens.Spacing.x12) {
                    // MARK: - Removed: карточка текстового поиска
                    // CardRow(icon: "text.magnifyingglass",
                    //         title: "Search for a partner by name") { goName = true }

                    // Оставляем только поиск по фото
                    CardRow(
                        icon: "face.smiling",
                        title: "Finding a partner by face"
                    ) { goPhoto = true }
                }

                Spacer()
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .background(Tokens.Color.backgroundMain.ignoresSafeArea())

            // MARK: - Removed: navigationDestination для NameSearchView
            .navigationDestination(isPresented: $goPhoto) {
                FaceSearchView(vm: vm)
            }
        }
    }
}

private struct CardRow: View {
    let icon: String
    let title: String
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            HStack(spacing: Tokens.Spacing.x12) {
                Image(systemName: icon)
                    .frame(width: 28, height: 28)
                    .foregroundStyle(Tokens.Color.accent)
                    .background(
                        Tokens.Color.accent.opacity(0.1),
                        in: RoundedRectangle(cornerRadius: 8, style: .continuous)
                    )
                Text(title)
                    .foregroundStyle(Tokens.Color.textPrimary)
                Spacer()
            }
            .padding(.vertical, Tokens.Spacing.x12)
            .padding(.horizontal, Tokens.Spacing.x12)
            .background(
                Tokens.Color.surfaceCard,
                in: RoundedRectangle(cornerRadius: 16, style: .continuous)
            )
            .shadow(color: .black.opacity(0.06), radius: 8, y: 2)
        }
        .buttonStyle(.plain)
    }
}
//
//  NameSearchView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//

import SwiftUI
import Swinject // MARK: - Added

struct NameSearchView: View {
    @ObservedObject var vm: SearchViewModel
    @Environment(\.dismiss) private var dismiss
    @Environment(\.resolver) private var resolver // MARK: - Added

    @State private var goResults = false
    @State private var didSubmit = false
    @State private var showPaywall = false // MARK: - Added

    var body: some View {
        ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            VStack(alignment: .leading, spacing: Tokens.Spacing.x16) {
                // Header
                HStack {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "arrow.left")
                            .font(.system(size: 16, weight: .semibold))
                            .foregroundStyle(Tokens.Color.textPrimary)
                            .padding(12)
                            .background(
                                Tokens.Color.surfaceCard,
                                in: RoundedRectangle(cornerRadius: 16, style: .continuous)
                            )
                            .apply(Tokens.Shadow.card)
                    }

                    Spacer()

                    Text("Name search")
                        .font(Tokens.Font.title)
                        .foregroundStyle(Tokens.Color.textPrimary)

                    Spacer().frame(width: 44) // симметрия
                }
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.top, Tokens.Spacing.x16)

                // Search field
                VStack(spacing: Tokens.Spacing.x16) {
                    SearchField("Partner's name...", text: $vm.query)
                        .padding(.horizontal, Tokens.Spacing.x16)

                    Spacer(minLength: Tokens.Spacing.x16)
                }
            }
        }
        .navigationBarBackButtonHidden(true)
        .navigationBarTitleDisplayMode(.inline)

        // Нижняя большая кнопка Find
        .safeAreaInset(edge: .bottom) {
            HStack {
                PrimaryButton(
                    "Find",
                    isLoading: vm.isLoading,
                    isDisabled: vm.query.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty || vm.isLoading
                ) {
                    // MARK: - Added (premium gate)
                    let isPremium = (resolver.resolve(PremiumStore.self)?.isPremium ?? false)
                    guard isPremium else {
                        showPaywall = true
                        return
                    }
                    didSubmit = true
                    vm.runNameSearch()
                }
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.vertical, Tokens.Spacing.x16)
            .background(
                Tokens.Color.backgroundMain,
                ignoresSafeAreaEdges: .bottom
            )
        }

        // Переход к результатам после завершения загрузки
        .onChange(of: vm.isLoading) { was, isNow in
            if didSubmit && was == true && isNow == false {
                didSubmit = false
                goResults = true
            }
        }
        .navigationDestination(isPresented: $goResults) {
            SearchResultsView(results: vm.results, mode: .name)
        }

        // Блокирующая "загрузка"
        .fullScreenCover(
            isPresented: Binding(
                get: { vm.isBlockingLoading },
                set: { _ in }
            )
        ) {
            LoadingView(mode: .name, previewImage: nil, cancelAction: nil)
                .interactiveDismissDisabled(true)
        }

        // MARK: - Added Paywall
        .sheet(isPresented: $showPaywall) {
            let paywallVM = resolver.resolve(PaywallViewModel.self)!
            PaywallView(vm: paywallVM)
                .presentationDetents([.large])
        }
    }
}
//
//  SearchResultsView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import SwiftUI

struct SearchResultsView: View {
    enum Mode { case face, name }

    let results: [ImageHit]
    let mode: Mode

    private let columns = [
        GridItem(.flexible(), spacing: Tokens.Spacing.x16),
        GridItem(.flexible(), spacing: Tokens.Spacing.x16)
    ]

    @Namespace private var ns

    var body: some View {
        ScrollView {
            if results.isEmpty {
                ContentUnavailableView(
                    "No results found",
                    systemImage: "magnifyingglass.circle",
                    description: Text("No matches found. Please try a different photo or name.")
                )
                .padding(.top, Tokens.Spacing.x24)
            } else {
                LazyVGrid(columns: columns, spacing: Tokens.Spacing.x16) {
                    ForEach(results) { hit in
                        if mode == .face {
                            FaceResultCard(hit: hit)
                        } else {
                            NameResultCard(hit: hit)
                        }
                    }
                }
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.vertical, Tokens.Spacing.x24)
                .animation(.easeInOut(duration: 0.25), value: results)
            }
        }
        .background(Tokens.Color.backgroundMain.ignoresSafeArea())
        .navigationTitle(mode == .face ? "Face results" : "Name results")
        .navigationBarTitleDisplayMode(.inline)
    }
}

// MARK: - Cards

private struct FaceResultCard: View {
    let hit: ImageHit

    var body: some View {
        VStack(spacing: Tokens.Spacing.x8) {
            AsyncThumb(url: hit.thumbnailURL)
                .frame(height: 160)
                .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            Tokens.Color.surfaceCard,
            in: RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
        )
        .apply(Tokens.Shadow.card)
    }
}

private struct NameResultCard: View {
    let hit: ImageHit

    var body: some View {
        VStack(alignment: .leading, spacing: Tokens.Spacing.x8) {
            AsyncThumb(url: hit.thumbnailURL)
                .frame(height: 160)
                .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))

            VStack(alignment: .leading, spacing: 2) {
                Text(hit.title)
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.textPrimary)
                    .lineLimit(1)
                Text(hit.source)
                    .font(Tokens.Font.captionRegular)
                    .foregroundStyle(Tokens.Color.textSecondary)
                    .lineLimit(1)
            }

            if let url = hit.linkURL {
                Link(destination: url) {
                    HStack(spacing: 4) {
                        Text("Open")
                        Image(systemName: "arrow.up.right.square")
                    }
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.accent)
                }
                .padding(.top, Tokens.Spacing.x4)
            }
        }
        .padding(Tokens.Spacing.x12)
        .background(
            Tokens.Color.surfaceCard,
            in: RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
        )
        .apply(Tokens.Shadow.card)
    }
}

private struct AsyncThumb: View {
    let url: URL?
    var body: some View {
        AsyncImage(url: url) { phase in
            switch phase {
            case .empty:
                ZStack { Color.gray.opacity(0.1); ProgressView() }
            case .success(let image):
                image.resizable().scaledToFill().clipped()
            case .failure:
                ZStack {
                    Color.gray.opacity(0.2)
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundStyle(.gray)
                }
            @unknown default:
                EmptyView()
            }
        }
    }
}
//
//  RateUsView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//



import SwiftUI
import StoreKit

struct RateUsView: View {
    /// Имя PDF-ассета: "rateus_hand" или "rateus_stars"
    let imageName: String

    /// Колбэк закрытия (например, "Rate later")
    let onLater: () -> Void
    /// Колбэк после "Rate now" (покажем системный рейтинг и закроем)
    let onRated: () -> Void

    init(
        imageName: String = "rateus_hand",
        onLater: @escaping () -> Void,
        onRated: @escaping () -> Void
    ) {
        self.imageName = imageName
        self.onLater = onLater
        self.onRated = onRated
    }

    var body: some View {
        ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            VStack(spacing: 0) {
                Spacer(minLength: 24)

                // Иллюстрация — PDF, адаптивно
                GeometryReader { geo in
                    let side = min(geo.size.width * 0.6, 260)
                    Image(imageName)
                        .resizable()
                        .scaledToFit()
                        .frame(width: side, height: side)
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                }
                .frame(height: 300)

                Spacer(minLength: 0)

                VStack(spacing: 14) {
                    Text("Love using Cheater Booster?")
                        .font(Tokens.Font.h2)
                        .multilineTextAlignment(.center)
                        .foregroundStyle(Tokens.Color.textPrimary)
                        .padding(.horizontal, 24)

                    Text("Leave a quick rating to help others discover it — your support means a lot!")
                        .font(Tokens.Font.body)
                        .foregroundStyle(Tokens.Color.textSecondary)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal, 24)
                }
                .padding(.bottom, 24)

                // Кнопка "Rate later" — outline
                Button(action: { onLater() }) {
                    Text("Rate later")
                        .font(Tokens.Font.subtitle)
                        .foregroundStyle(Tokens.Color.textPrimary)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 16)
                        .background(
                            RoundedRectangle(cornerRadius: Tokens.Radius.pill, style: .continuous)
                                .fill(Tokens.Color.surfaceCard)
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: Tokens.Radius.pill, style: .continuous)
                                .stroke(Tokens.Color.accent, lineWidth: 1.5)
                        )
                }
                .buttonStyle(.plain)
                .padding(.horizontal, 24)

                // Кнопка "Rate now" — primary (на твоём PrimaryButton)
                PrimaryButton("Rate now") {
                    SKStoreReviewController.requestReview()
                    onRated()
                }
                .padding(.horizontal, 24)
                .padding(.top, 12)

                Spacer(minLength: 24)
            }
        }
        .accessibilityIdentifier("rateus.screen")
    }
}
//
//  LoadingView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import SwiftUI

struct LoadingView: View {
    enum Mode { case name, face }

    let mode: Mode
    let previewImage: UIImage?
    let cancelAction: (() -> Void)?

    @State private var progress: CGFloat = 0.35 // моковый прогресс для визуала

    var body: some View {
        ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            VStack(spacing: Tokens.Spacing.x24) {
                if mode == .face, let ui = previewImage {
                    Image(uiImage: ui)
                        .resizable()
                        .scaledToFit()
                        .frame(maxWidth: .infinity)
                        .frame(height: 260)
                        .padding(.horizontal, Tokens.Spacing.x16)
                        .clipShape(RoundedRectangle(cornerRadius: 22, style: .continuous))
                        .overlay(
                            RoundedRectangle(cornerRadius: 22, style: .continuous)
                                .stroke(Tokens.Color.borderNeutral, lineWidth: 1)
                        )

                    Text("Photo analysis")
                        .font(Tokens.Font.bodyMedium18)
                        .foregroundStyle(Tokens.Color.textPrimary)

                    // Простой прогресс (визуальный)
                    ZStack(alignment: .leading) {
                        Capsule().fill(Tokens.Color.borderNeutral.opacity(0.4)).frame(height: 8)
                        Capsule().fill(Tokens.Color.accent).frame(width: progressWidth, height: 8)
                    }
                    .padding(.horizontal, Tokens.Spacing.x16)
                } else {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: Tokens.Color.accent))
                        .scaleEffect(1.6)

                    Text("Searching...")
                        .font(Tokens.Font.bodyMedium18)
                        .foregroundStyle(Tokens.Color.textPrimary)
                }

                if let cancelAction {
                    Button("Cancel") { cancelAction() }
                        .font(Tokens.Font.caption)
                        .foregroundStyle(Tokens.Color.textSecondary)
                        .padding(.top, Tokens.Spacing.x8)
                }

                Spacer(minLength: 0)
            }
            .padding(.top, Tokens.Spacing.x24)
        }
        .onAppear {
            // лёгкая псевдо-анимация прогресса
            withAnimation(.easeInOut(duration: 0.9).repeatForever(autoreverses: true)) {
                progress = 0.7
            }
        }
    }

    private var progressWidth: CGFloat {
        UIScreen.main.bounds.width * progress
    }
}
//
//  HistoryViewModel.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//



import Foundation
import Combine
import UIKit

final class HistoryViewModel: ObservableObject {

    @Published private(set) var items: [HistoryRecord] = []
    @Published private(set) var cheaterItems: [CheaterRecord] = []
    @Published var segment: Segment = .search

    enum Segment: Equatable { case search, cheater }

    @Published private(set) var rerunResults: [ImageHit] = []
    @Published private(set) var isLoading = false
    @Published var errorText: String?

    @Published var selectedCheater: CheaterRecord?

    private let store: HistoryStore
    private let cheaterStore: CheaterStore
    private let search: SearchService
    private var bag = Set<AnyCancellable>()

    init(store: HistoryStore,
         cheaterStore: CheaterStore,
         search: SearchService) {
        self.store = store
        self.cheaterStore = cheaterStore
        self.search = search
        reload()
    }

    func reload() {
        items = store.load()
        cheaterItems = cheaterStore.load()
    }

    func clearSearch() {
        store.clearAll()
        items = []
    }

    func clearCheater() {
        cheaterStore.clearAll()
        cheaterItems = []
    }

    func onTapSearch(_ rec: HistoryRecord) {
        isLoading = true
        errorText = nil

        let pub: AnyPublisher<[ImageHit], Error>
        if rec.kind == .name, let q = rec.query {
            pub = search.searchByName(q)
        } else if rec.kind == .face, let data = rec.imageJPEG {
            pub = search.searchByImage(data)
        } else {
            isLoading = false
            return
        }

        pub
            .receive(on: DispatchQueue.main)
            .sink { [weak self] comp in
                self?.isLoading = false
                if case .failure(let err) = comp {
                    self?.errorText = err.localizedDescription
                }
            } receiveValue: { [weak self] hits in
                self?.rerunResults = hits
            }
            .store(in: &bag)
    }

    func onTapCheater(_ rec: CheaterRecord) {
        selectedCheater = rec
    }
}
//  HistoryView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//

import SwiftUI
import UIKit
import Swinject // MARK: - Added

struct HistoryView: View {
    @StateObject private var vm: HistoryViewModel
    @EnvironmentObject private var router: AppRouter
    @Environment(\.resolver) private var resolver // MARK: - Added
    @State private var goResults = false
    @State private var showPaywall = false // MARK: - Added

    init(vm: HistoryViewModel) {
        _vm = StateObject(wrappedValue: vm)
    }

    var body: some View {
        NavigationStack {
            content
                .background(Tokens.Color.backgroundMain.ignoresSafeArea())
                .navigationBarTitleDisplayMode(.inline)
                .onAppear {
                    vm.reload()
                    vm.segment = router.historyPreferredSegment
                }
                .onChange(of: router.historyPreferredSegment) { _, seg in
                    vm.segment = seg
                }
                .onChange(of: vm.rerunResults) { _, hits in
                    if !hits.isEmpty { goResults = true }
                }
                // Было: mode: .name — меняем на .face, т.к. теперь доступен только поиск по фото
                .navigationDestination(isPresented: $goResults) {
                    SearchResultsView(results: vm.rerunResults, mode: .face)
                }
                .navigationDestination(item: $vm.selectedCheater) { rec in
                    CheaterResultView(record: rec)
                }
        }
        // Paywall (как и было добавлено ранее)
        .sheet(isPresented: $showPaywall) {
            let paywallVM = resolver.resolve(PaywallViewModel.self)!
            PaywallView(vm: paywallVM)
                .presentationDetents([.large])
        }
    }

    private var content: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Text("History")
                    .font(Tokens.Font.title)
                    .foregroundStyle(Tokens.Color.textPrimary)
                Spacer()
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.top, Tokens.Spacing.x16)

            SegmentCapsule(selected: $vm.segment, router: router)
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.top, Tokens.Spacing.x12)

            Group {
                if vm.segment == .search {
                    topBarClear(isHidden: vm.items.isEmpty) { vm.clearSearch() }
                    SearchList(items: vm.items) { rec in
                        // Если запись текстового поиска — не перезапускаем (функции нет).
                        guard rec.kind == .face else {
                            // Мягко ничего не делаем; можно подсветить тостом в будущем.
                            return
                        }

                        // Premium-гейт оставляем без изменений:
                        let isPremium = (resolver.resolve(PremiumStore.self)?.isPremium ?? false)
                        if isPremium {
                            vm.onTapSearch(rec)
                        } else {
                            showPaywall = true
                        }
                    }
                    .padding(.horizontal, Tokens.Spacing.x16)
                    .padding(.top, Tokens.Spacing.x16)
                } else {
                    topBarClear(isHidden: vm.cheaterItems.isEmpty) { vm.clearCheater() }
                    CheaterList(items: vm.cheaterItems) { rec in vm.onTapCheater(rec) }
                        .padding(.horizontal, Tokens.Spacing.x16)
                        .padding(.top, Tokens.Spacing.x16)
                }
            }
            Spacer(minLength: 0)
        }
    }

    @ViewBuilder
    private func topBarClear(isHidden: Bool, action: @escaping () -> Void) -> some View {
        HStack {
            Spacer()
            if !isHidden {
                Button("Clear") { action() }
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.accent)
            }
        }
        .padding(.horizontal, Tokens.Spacing.x16)
        .padding(.top, Tokens.Spacing.x8)
    }
}

// MARK: - Search list (как было)
import SwiftUI

private struct SearchList: View {
    let items: [HistoryRecord]
    let onTap: (HistoryRecord) -> Void

    var body: some View {
        ScrollView {
            LazyVStack(spacing: Tokens.Spacing.x12) {
                ForEach(items) { rec in
                    Button { onTap(rec) } label: {
                        SearchRow(rec: rec)
                    }
                    .buttonStyle(.plain)
                }
            }
            .padding(.bottom, Tokens.Spacing.x24)
        }
    }
}

private struct SearchRow: View {
    let rec: HistoryRecord

    private var titleText: String {
        if let t = rec.titlePreview, !t.isEmpty { return t }
        switch rec.kind {
        case .name:
            // Текстовый поиск убран — показываем нейтральную подпись, если в истории внезапно окажется запись старого формата
            return rec.query?.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty == false
                ? (rec.query ?? "Name search")
                : "Name search"
        case .face:
            return "Face search"
        }
    }

    private var subtitleText: String {
        if let s = rec.sourcePreview, !s.isEmpty { return s }
        return DateFormatter.historyDate.string(from: rec.createdAt)
    }

    var body: some View {
        HStack(spacing: Tokens.Spacing.x12) {
            ZStack {
                Tokens.Color.backgroundMain
                Image(systemName: rec.kind == .name ? "text.magnifyingglass" : "face.smiling")
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundStyle(Tokens.Color.accent)
            }
            .frame(width: 48, height: 48)
            .background(
                RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
                    .fill(Tokens.Color.surfaceCard)
            )

            VStack(alignment: .leading, spacing: 4) {
                Text(titleText)
                    .font(Tokens.Font.body)
                    .foregroundStyle(Tokens.Color.textPrimary)

                Text(subtitleText)
                    .font(Tokens.Font.captionRegular)
                    .foregroundStyle(Tokens.Color.textSecondary)
                    .lineLimit(1)
            }

            Spacer()
        }
        .padding(.vertical, Tokens.Spacing.x12)
        .padding(.horizontal, Tokens.Spacing.x12)
        .background(
            Tokens.Color.surfaceCard,
            in: RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
        )
        .apply(Tokens.Shadow.card)
    }
}

// MARK: - Cheater list (без изменений)
private struct CheaterList: View {
    let items: [CheaterRecord]
    let onTap: (CheaterRecord) -> Void

    var body: some View {
        if items.isEmpty {
            ContentUnavailableView(
                "No cheater items yet",
                systemImage: "text.magnifyingglass",
                description: Text("Analyze a chat to see it here.")
            )
            .padding(.top, Tokens.Spacing.x24)
        } else {
            ScrollView {
                LazyVStack(spacing: Tokens.Spacing.x12) {
                    ForEach(items) { rec in
                        Button { onTap(rec) } label: {
                            CheaterRow(rec: rec)
                        }
                        .buttonStyle(.plain)
                    }
                }
                .padding(.bottom, Tokens.Spacing.x24)
            }
        }
    }
}

private struct CheaterRow: View {
    let rec: CheaterRecord

    var body: some View {
        HStack(spacing: Tokens.Spacing.x12) {
            ZStack {
                Tokens.Color.backgroundMain
                Image(systemName: rec.kind == .file ? "folder" : "photo")
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundStyle(Tokens.Color.accent)
            }
            .frame(width: 44, height: 44)
            .clipShape(RoundedRectangle(cornerRadius: 14, style: .continuous))

            VStack(alignment: .leading, spacing: 4) {
                Text("High risk level")
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.textPrimary)
                if let note = rec.note, !note.isEmpty {
                    Text(note)
                        .font(Tokens.Font.captionRegular)
                        .foregroundStyle(Tokens.Color.textSecondary)
                        .lineLimit(1)
                }
            }

            Spacer()

            Text("\(rec.riskScore)%")
                .font(Tokens.Font.caption)
                .foregroundStyle(Tokens.Color.textPrimary)
        }
        .padding(.vertical, Tokens.Spacing.x12)
        .padding(.horizontal, Tokens.Spacing.x12)
        .background(
            Tokens.Color.surfaceCard,
            in: RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
        )
        .apply(Tokens.Shadow.card)
    }
}

// MARK: - DateFormatter
private extension DateFormatter {
    static let historyDate: DateFormatter = {
        let df = DateFormatter()
        df.dateStyle = .medium
        df.timeStyle = .short
        return df
    }()
}

// MARK: - Segment (без изменений)
private struct SegmentCapsule: View {
    @Binding var selected: HistoryViewModel.Segment
    @ObservedObject var router: AppRouter

    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 22, style: .continuous)
                .fill(Tokens.Color.surfaceCard)
                .apply(Tokens.Shadow.card)

            HStack(spacing: 0) {
                seg("Search", .search)
                seg("Cheater", .cheater)
            }
        }
        .frame(height: 44)
    }

    private func seg(_ title: String, _ seg: HistoryViewModel.Segment) -> some View {
        Button {
            selected = seg
            router.rememberHistorySegment(seg)
        } label: {
            Text(title)
                .font(Tokens.Font.caption)
                .foregroundStyle(selected == seg ? .white : Tokens.Color.textPrimary)
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .background(
                    Group {
                        if selected == seg {
                            RoundedRectangle(cornerRadius: 22, style: .continuous)
                                .fill(Tokens.Color.accent)
                        }
                    }
                )
        }
        .buttonStyle(.plain)
    }
}
//
//  CheaterView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import SwiftUI
import PhotosUI
import UniformTypeIdentifiers
import Swinject // MARK: - Added

struct CheaterView: View {
    @ObservedObject var vm: CheaterViewModel
    @EnvironmentObject private var router: AppRouter
    @Environment(\.resolver) private var resolver // MARK: - Added

    // PhotosPicker
    @State private var photoItem: PhotosPickerItem?
    @State private var showPhotoPicker = false

    // Document picker
    @State private var showFilePicker = false

    // Optional text conversation
    @State private var conversationText: String = ""

    // Alert after saving
    @State private var showSavedAlert = false

    // MARK: - Added
    @State private var showPaywall = false

    init(vm: CheaterViewModel) {
        self.vm = vm
    }

    var body: some View {
        VStack(spacing: Tokens.Spacing.x16) {
            content
        }
        .padding(.horizontal, Tokens.Spacing.x16)
        .padding(.top, Tokens.Spacing.x24)
        .background(Tokens.Color.backgroundMain.ignoresSafeArea())
        .navigationTitle("Cheater")

        // MARK: Pickers
        .photosPicker(isPresented: $showPhotoPicker,
                      selection: $photoItem,
                      matching: .images)

        .fileImporter(
            isPresented: $showFilePicker,
            allowedContentTypes: [.pdf, .png, .jpeg, .plainText],
            allowsMultipleSelection: false
        ) { result in
            switch result {
            case .success(let urls):
                guard let url = urls.first else { return }
                let secured = url.startAccessingSecurityScopedResource()
                defer { if secured { url.stopAccessingSecurityScopedResource() } }
                do {
                    let data = try Data(contentsOf: url)
                    vm.showFile(name: url.lastPathComponent, data: data)
                } catch {
                    vm.presentError("Failed to read file: \(error.localizedDescription)")
                }

            case .failure(let error):
                vm.presentError(error.localizedDescription)
            }
        }

        .onChange(of: photoItem) { item in
            guard let item else { return }
            Task {
                if let data = try? await item.loadTransferable(type: Data.self),
                   let img  = UIImage(data: data) {
                    await MainActor.run { vm.showImage(img) }
                } else {
                    await MainActor.run { vm.presentError("Failed to load photo") }
                }
                await MainActor.run { photoItem = nil }
            }
        }

        // MARK: - Save Alert
        .onChange(of: vm.didSave) { _, saved in
            guard saved else { return }
            showSavedAlert = true
        }
        .alert("Saved to History", isPresented: $showSavedAlert) {
            Button("Open History") {
                // Детеминированная навигация через роутер:
                router.openHistoryCheater()
            }
            Button("OK", role: .cancel) { }
        }

        // MARK: - Added Paywall
        .sheet(isPresented: $showPaywall) {
            let paywallVM = resolver.resolve(PaywallViewModel.self)!
            PaywallView(vm: paywallVM)
                .presentationDetents([.large])
        }
    }

    // MARK: - Content

    @ViewBuilder
    private var content: some View {
        switch vm.state {
        case .idle:
            idleView
        case .previewImage(let img):
            imagePreview(img)
        case .previewFile(let name, _):
            filePreview(name: name)
        case .uploading(let p):
            uploadingView(progress: p)
        case .result(let r):
            resultView(r)
        case .error(let msg):
            errorView(msg)
        }
    }

    // MARK: - Subviews (без изменений ниже, кроме premium-гейта в Анализ)

    private var idleView: some View {
        VStack(spacing: Tokens.Spacing.x24) {
            VStack(spacing: Tokens.Spacing.x8) {
                Image(systemName: "photo.on.rectangle.angled")
                    .font(.system(size: 56))
                    .foregroundColor(Tokens.Color.textSecondary)
                Text("Select photo or file to analyse")
                    .font(Tokens.Font.body)
                    .foregroundColor(Tokens.Color.textPrimary)
                    .multilineTextAlignment(.center)
            }
            .padding(.top, Tokens.Spacing.x16)

            PrimaryButton("Pick photo") { showPhotoPicker = true }
            PrimaryButton("Pick file")  { showFilePicker  = true }

            Spacer(minLength: 0)
        }
    }

    private func imagePreview(_ img: UIImage) -> some View {
        VStack(spacing: Tokens.Spacing.x16) {
            ScrollView {
                Image(uiImage: img)
                    .resizable()
                    .scaledToFit()
                    .cornerRadius(Tokens.Radius.medium)
                    .overlay(
                        RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
                            .stroke(Tokens.Color.borderNeutral, lineWidth: 1)
                    )
            }

            PrimaryButton("Analyse") {
                // MARK: - Added (premium gate)
                let isPremium = (resolver.resolve(PremiumStore.self)?.isPremium ?? false)
                guard isPremium else {
                    showPaywall = true
                    return
                }
                vm.analyseCurrent(conversation: conversationText, apphudId: "debug-apphud-id")
            }

            Button("Choose another…") { showSourceActionSheet() }
                .font(Tokens.Font.body)
                .foregroundColor(Tokens.Color.textSecondary)
        }
    }

    private func filePreview(name: String) -> some View {
        VStack(spacing: Tokens.Spacing.x16) {
            VStack(spacing: Tokens.Spacing.x12) {
                Image(systemName: "doc.richtext")
                    .font(.system(size: 56))
                    .foregroundColor(Tokens.Color.textSecondary)
                Text(name)
                    .font(Tokens.Font.body)
                    .foregroundColor(Tokens.Color.textPrimary)
                    .multilineTextAlignment(.center)
            }
            .padding(.top, Tokens.Spacing.x16)

            PrimaryButton("Analyse") {
                // MARK: - Added (premium gate)
                let isPremium = (resolver.resolve(PremiumStore.self)?.isPremium ?? false)
                guard isPremium else {
                    showPaywall = true
                    return
                }
                vm.analyseCurrent(conversation: conversationText, apphudId: "debug-apphud-id")
            }

            Button("Choose another…") { showSourceActionSheet() }
                .font(Tokens.Font.body)
                .foregroundColor(Tokens.Color.textSecondary)
            Spacer(minLength: 0)
        }
    }

    private func uploadingView(progress p: Int) -> some View {
        VStack(spacing: Tokens.Spacing.x16) {
            ProgressView(value: Double(p), total: 100)
                .padding(.horizontal, Tokens.Spacing.x16)
            Text("\(p)%")
                .font(Tokens.Font.body)
                .foregroundColor(Tokens.Color.textSecondary)
            Spacer(minLength: 0)
        }
    }

    private func resultView(_ r: TaskResult) -> some View {
        VStack(alignment: .leading, spacing: Tokens.Spacing.x16) {
            Text("Risk analysis complete ✅")
                .font(Tokens.Font.title)
                .foregroundColor(Tokens.Color.textPrimary)

            Text("\(r.risk_score)%")
                .font(Tokens.Font.h1)
                .foregroundColor(Tokens.Color.textPrimary)

            Text(riskLevelText(r.risk_score))
                .font(Tokens.Font.body)
                .foregroundColor(Tokens.Color.textSecondary)

            Divider()

            Text("Red flags").font(Tokens.Font.subtitle)
            ForEach(r.red_flags, id: \.self) { Text("• \($0)") }

            Divider()

            Text("Recommendations").font(Tokens.Font.subtitle)
            ForEach(r.recommendations, id: \.self) { Text("• \($0)") }

            PrimaryButton("Save to History") { vm.saveToHistory() }

            ShareLink(item: shareText(for: r)) {
                Text("Share")
                    .font(Tokens.Font.caption)
                    .foregroundStyle(.white)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                    .background(
                        Tokens.Color.accent,
                        in: RoundedRectangle(cornerRadius: Tokens.Radius.pill, style: .continuous)
                    )
            }

            Button("Select another") { showSourceActionSheet() }
                .font(Tokens.Font.body)
                .foregroundColor(Tokens.Color.textSecondary)
                .padding(.top, Tokens.Spacing.x8)

            Spacer(minLength: 0)
        }
    }

    private func errorView(_ msg: String) -> some View {
        VStack(spacing: Tokens.Spacing.x16) {
            Text(msg)
                .font(Tokens.Font.body)
                .foregroundColor(.red)
                .multilineTextAlignment(.center)

            PrimaryButton("Try again") { showSourceActionSheet() }
            Spacer(minLength: 0)
        }
    }

    private func riskLevelText(_ score: Int) -> String {
        switch score {
        case 0..<34:  return "Low risk level"
        case 34..<67: return "Medium risk level"
        default:      return "High risk level"
        }
    }

    private func shareText(for r: TaskResult) -> String {
        """
        CheaterBuster — analysis result:
        Risk: \(r.risk_score)%
        Red flags: \(r.red_flags.joined(separator: "; "))
        Recommendations: \(r.recommendations.joined(separator: "; "))
        """
    }

    private func showSourceActionSheet() {
        showPhotoPicker = true
    }
}
//
//  CheaterResultView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//


import SwiftUI

struct CheaterResultView: View {
    let record: CheaterRecord

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: Tokens.Spacing.x16) {
                // Заголовок + процент
                Text("Risk analysis")
                    .font(Tokens.Font.title)
                    .foregroundStyle(Tokens.Color.textPrimary)

                HStack(alignment: .firstTextBaseline, spacing: Tokens.Spacing.x12) {
                    Text("\(record.riskScore)%")
                        .font(Tokens.Font.h1)
                        .foregroundStyle(Tokens.Color.textPrimary)
                    Text(riskLevelText(record.riskScore))
                        .font(Tokens.Font.body)
                        .foregroundStyle(Tokens.Color.textSecondary)
                }

                if let note = record.note, !note.isEmpty {
                    Text(note)
                        .font(Tokens.Font.captionRegular)
                        .foregroundStyle(Tokens.Color.textSecondary)
                }

                Divider()

                // Red flags
                Text("Red flags")
                    .font(Tokens.Font.subtitle)
                    .foregroundStyle(Tokens.Color.textPrimary)

                if record.redFlags.isEmpty {
                    Text("No red flags found.")
                        .font(Tokens.Font.captionRegular)
                        .foregroundStyle(Tokens.Color.textSecondary)
                } else {
                    VStack(alignment: .leading, spacing: 8) {
                        ForEach(record.redFlags, id: \.self) { flag in
                            HStack(alignment: .top, spacing: 8) {
                                Text("•")
                                Text(flag)
                            }
                            .font(Tokens.Font.body)
                            .foregroundStyle(Tokens.Color.textPrimary)
                        }
                    }
                }

                Divider()

                // Recommendations
                Text("Recommendations")
                    .font(Tokens.Font.subtitle)
                    .foregroundStyle(Tokens.Color.textPrimary)

                if record.recommendations.isEmpty {
                    Text("No recommendations.")
                        .font(Tokens.Font.captionRegular)
                        .foregroundStyle(Tokens.Color.textSecondary)
                } else {
                    VStack(alignment: .leading, spacing: 8) {
                        ForEach(record.recommendations, id: \.self) { rec in
                            HStack(alignment: .top, spacing: 8) {
                                Text("•")
                                Text(rec)
                            }
                            .font(Tokens.Font.body)
                            .foregroundStyle(Tokens.Color.textPrimary)
                        }
                    }
                }

                Spacer(minLength: 0)
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.top, Tokens.Spacing.x16)
        }
        .background(Tokens.Color.backgroundMain.ignoresSafeArea())
        .navigationTitle("Cheater result")
        .navigationBarTitleDisplayMode(.inline)
    }

    private func riskLevelText(_ score: Int) -> String {
        switch score {
        case 0..<34:  return "Low risk level"
        case 34..<67: return "Medium risk level"
        default:      return "High risk level"
        }
    }
}
//
//  CheaterViewModel.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import UIKit
import Combine

@MainActor
final class CheaterViewModel: ObservableObject {

    enum State {
        case idle
        case previewImage(UIImage)
        case previewFile(name: String, data: Data)
        case uploading(progress: Int)
        case result(TaskResult)
        case error(String)
    }

    @Published private(set) var state: State = .idle

    // E8: храним последний результат (для Save/Share)
    private var lastKind: CheaterRecord.Kind?
    private var lastResult: TaskResult?

    // Сигнал «сохранено» для экрана (для перехода на History)
    @Published private(set) var didSave: Bool = false

    private let auth: AuthRepository
    private let api: CheaterAPI
    private let poller: TaskPoller
    private let store: CheaterStore
    private let cfg: APIConfig

    init(auth: AuthRepository, api: CheaterAPI, poller: TaskPoller, store: CheaterStore, cfg: APIConfig) {
        self.auth = auth; self.api = api; self.poller = poller; self.store = store; self.cfg = cfg
    }

    func showImage(_ image: UIImage) { state = .previewImage(image) }
    func showFile(name: String, data: Data) { state = .previewFile(name: name, data: data) }

    /// Публичный метод, чтобы экран мог показать ошибку, не трогая `state` напрямую.
    func presentError(_ message: String) { state = .error(message) }

    /// Старт анализа, теперь **не** сохраняем авто в историю — ждём явного Save.
    func analyseCurrent(conversation: String? = nil, apphudId: String) {
        Task {
            do {
                try await auth.ensureAuthorized(apphudId: apphudId)

                switch state {
                case .previewImage(let img):
                    guard let data = img.jpegData(compressionQuality: 0.9) else { throw APIError.noData }
                    try await runTask(files: [
                        .init(name: "files", filename: "image.jpg", mimeType: "image/jpeg", data: data)
                    ], conversation: conversation, kind: .image)

                case .previewFile(let name, let data):
                    try await runTask(files: [
                        .init(name: "files", filename: name, mimeType: mime(for: name), data: data)
                    ], conversation: conversation, kind: .file)

                default:
                    break
                }
            } catch {
                presentError((error as? LocalizedError)?.errorDescription ?? error.localizedDescription)
            }
        }
    }

    /// Явное сохранение результата анализа в историю.
    func saveToHistory(note: String? = "AI risk analysis") {
        guard let kind = lastKind, let r = lastResult else { return }
        store.add(.init(
            date: Date(),
            kind: kind,
            riskScore: r.risk_score,
            note: note,
            redFlags: r.red_flags,
            recommendations: r.recommendations
        ))
        didSave = true
    }

    // MARK: - Private

    private func runTask(files: [MultipartFormData.FilePart], conversation: String?, kind: CheaterRecord.Kind) async throws {
        state = .uploading(progress: 10)

        let created = try await api.createAnalyzeTask(files: files, conversation: conversation)
        state = .uploading(progress: 35)

        let final: TaskReadDTO
        switch created.status {
        case .finished, .failed:
            final = created
        default:
            final = try await poller.waitForAnalyzeResult(taskId: created.id, interval: 1.0)
        }

        switch final.status {
        case .finished:
            if case .details(let r)? = final.result {
                // E8: не сохраняем автоматически — показываем пользователю, а затем Save.
                lastKind = kind
                lastResult = r
                state = .result(r)
            } else if case .message(let msg)? = final.result {
                presentError(msg)
            } else {
                presentError("Empty result")
            }

        case .failed:
            presentError(final.error ?? "Analysis failed")

        default:
            presentError("Unexpected status: \(final.status)")
        }
    }

    private func mime(for filename: String) -> String {
        let ext = (filename as NSString).pathExtension.lowercased()
        switch ext {
        case "jpg","jpeg": return "image/jpeg"
        case "png":        return "image/png"
        case "pdf":        return "application/pdf"
        case "txt":        return "text/plain"
        default:           return "application/octet-stream"
        }
    }
}
//
//  PaywallView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//

import SwiftUI
import Combine

struct PaywallView: View {
    @ObservedObject var vm: PaywallViewModel
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack(spacing: 0) {
            // Верхняя иллюстрация
            Image(systemName: "person.crop.square.fill")
                .resizable()
                .scaledToFit()
                .frame(height: 180)
                .foregroundStyle(Tokens.Color.accent.opacity(0.8))
                .padding(.top, Tokens.Spacing.x24)

            // Заголовок
            Text("Unlock the full power of AI")
                .font(Tokens.Font.title)
                .foregroundStyle(Tokens.Color.textPrimary)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.top, Tokens.Spacing.x16)

            // Фича-лист (упрощённый один айтем как на макете)
            RoundedRectangle(cornerRadius: 18, style: .continuous)
                .fill(Tokens.Color.surfaceCard)
                .overlay(
                    HStack(alignment: .center, spacing: Tokens.Spacing.x12) {
                        Image(systemName: "heart.text.square")
                            .foregroundStyle(Tokens.Color.accent)
                            .font(.system(size: 22, weight: .semibold))
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Check your partner")
                                .font(Tokens.Font.body)
                                .foregroundStyle(Tokens.Color.textPrimary)
                            Text("Discover if your partner’s photos appear elsewhere.")
                                .font(Tokens.Font.captionRegular)
                                .foregroundStyle(Tokens.Color.textSecondary)
                                .fixedSize(horizontal: false, vertical: true)
                        }
                        Spacer()
                    }
                    .padding(.horizontal, Tokens.Spacing.x16)
                )
                .frame(height: 88)
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.top, Tokens.Spacing.x16)
                .apply(Tokens.Shadow.card)

            // Планы
            VStack(spacing: Tokens.Spacing.x12) {
                planRow(
                    title: "$9.99 / month",
                    subtitle: nil,
                    selected: vm.selected == .monthly
                ) { vm.selected = .monthly }

                planRow(
                    title: "$69.99 / year",
                    subtitle: "$5.83 / month billed annually",
                    selected: vm.selected == .yearly,
                    highlighted: true,
                    badge: "Save 41%"
                ) { vm.selected = .yearly }
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.top, Tokens.Spacing.x16)

            Text("Cancel at any time")
                .font(Tokens.Font.captionRegular)
                .foregroundStyle(Tokens.Color.textSecondary)
                .padding(.top, Tokens.Spacing.x16)

            // CTA
            PrimaryButton(
                vm.isProcessing ? "Processing..." : "Continue",
                isLoading: vm.isProcessing,
                isDisabled: vm.isProcessing
            ) {
                vm.buy()
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.top, Tokens.Spacing.x16)

            // Нижние ссылки
            HStack {
                Button("Privacy Policy") { /* TODO: открыть ссылку */ }
                Spacer()
                Button("Recover") { vm.restore() }
                Spacer()
                Button("Terms of Use") { /* TODO: открыть ссылку */ }
            }
            .font(Tokens.Font.captionRegular)
            .foregroundStyle(Tokens.Color.textSecondary)
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.vertical, Tokens.Spacing.x16)

            Spacer(minLength: 0)
        }
        .background(Tokens.Color.backgroundMain.ignoresSafeArea())
        .onChange(of: vm.didFinish) { _, done in
            if done { dismiss() }
        }
        .overlay(alignment: .topTrailing) {
            Button {
                dismiss()
            } label: {
                Image(systemName: "xmark")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundStyle(Tokens.Color.textSecondary)
                    .padding(12)
                    .background(
                        Tokens.Color.surfaceCard,
                        in: RoundedRectangle(cornerRadius: 14, style: .continuous)
                    )
                    .padding(.trailing, Tokens.Spacing.x16)
                    .padding(.top, Tokens.Spacing.x16)
            }
            .buttonStyle(.plain)
        }
        .alert("Error", isPresented: .constant(vm.errorText != nil), actions: {
            Button("OK") { vm.errorText = nil }
        }, message: {
            Text(vm.errorText ?? "")
        })
    }

    // MARK: - Subviews

    private func planRow(
        title: String,
        subtitle: String?,
        selected: Bool,
        highlighted: Bool = false,
        badge: String? = nil,
        action: @escaping () -> Void
    ) -> some View {
        Button(action: action) {
            HStack(alignment: .center, spacing: Tokens.Spacing.x12) {
                // Radio
                ZStack {
                    Circle().strokeBorder(selected ? Tokens.Color.accent : Tokens.Color.borderNeutral, lineWidth: 2)
                        .frame(width: 22, height: 22)
                    if selected {
                        Circle().fill(Tokens.Color.accent).frame(width: 10, height: 10)
                    }
                }

                VStack(alignment: .leading, spacing: 4) {
                    HStack(spacing: 8) {
                        Text(title)
                            .font(Tokens.Font.body)
                            .foregroundStyle(Tokens.Color.textPrimary)
                            .lineLimit(1)

                        if let badge {
                            Text(badge)
                                .font(Tokens.Font.captionRegular)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(Color.green.opacity(0.15), in: Capsule())
                        }
                    }

                    if let subtitle, !subtitle.isEmpty {
                        Text(subtitle)
                            .font(Tokens.Font.captionRegular)
                            .foregroundStyle(Tokens.Color.textSecondary)
                    }
                }

                Spacer()
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.vertical, Tokens.Spacing.x12)
            .background(
                RoundedRectangle(cornerRadius: 18, style: .continuous)
                    .stroke(
                        highlighted ? Tokens.Color.accent : Tokens.Color.borderNeutral.opacity(0.4),
                        lineWidth: highlighted ? 2 : 1
                    )
                    .background(
                        RoundedRectangle(cornerRadius: 18, style: .continuous)
                            .fill(Tokens.Color.surfaceCard)
                    )
            )
            .apply(Tokens.Shadow.card)
        }
        .buttonStyle(.plain)
    }
}
//
//  PaywallViewModel.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//

import Foundation
import Combine

@MainActor
final class PaywallViewModel: ObservableObject {

    // MARK: - Output
    @Published var selected: SubscriptionPlan = .yearly
    @Published private(set) var isProcessing: Bool = false
    @Published var errorText: String?
    @Published private(set) var didFinish: Bool = false

    // MARK: - Deps
    private let subscription: SubscriptionService

    init(subscription: SubscriptionService) {
        self.subscription = subscription
    }

    // MARK: - Intent
    func buy() {
        Task {
            await performPurchase()
        }
    }

    func restore() {
        Task {
            await performRestore()
        }
    }

    // MARK: - Added
    // MARK: - Private

    private func performPurchase() async {
        isProcessing = true
        errorText = nil
        do {
            try await subscription.purchase(plan: selected)
            didFinish = true
        } catch {
            errorText = error.localizedDescription
        }
        isProcessing = false
    }

    private func performRestore() async {
        isProcessing = true
        errorText = nil
        do {
            try await subscription.restore()
            didFinish = true
        } catch {
            errorText = error.localizedDescription
        }
        isProcessing = false
    }
}
//
//  OnboardingView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/31/25.
//

import SwiftUI

struct OnboardingView: View {
    // Один раз показываем онбординг
    @AppStorage("cb.hasOnboarded") private var hasOnboarded = false

    /// index: 0 = splash, 1..slides.count = реальный слайд
    @State private var index: Int = 0

    struct Slide: Identifiable, Hashable {
        let id = UUID()
        let imageName: String
        let title: String
        let subtitle: String
    }

    private let slides: [Slide] = [
        .init(
            imageName: "onboarding_face",
            title: "Find anyone by photo or name",
            subtitle: "Upload a photo or enter a name — AI will match profiles across the web."
        ),
        .init(
            imageName: "onboarding_phone",
            title: "Stay safe from scammers",
            subtitle: "AI protects you from fake profiles and scam chats."
        ),
        .init(
            imageName: "onboarding_couple",
            title: "Find out the truth in relationships",
            subtitle: "AI helps you check if your partner’s photos or profiles appear elsewhere."
        )
    ]

    var body: some View {
        ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            if index == 0 {
                // SPLASH (логотип по центру)
                Image("onboarding_logo")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 160, height: 160)
                    .transition(.opacity)
                    .onAppear {
                        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                            withAnimation(.easeInOut(duration: 0.25)) {
                                index = 1
                            }
                        }
                    }
            } else {
                VStack(spacing: 0) {
                    // MARK: Progress (верхние капсулы как в макете)
                    StepProgress(current: index, total: slides.count)
                        .padding(.horizontal, 16)
                        .padding(.top, 8)

                    // MARK: Контент слайдов
                    TabView(selection: $index) {
                        ForEach(Array(slides.enumerated()), id: \.offset) { offset, slide in
                            SlideScreen(
                                slide: slide,
                                isLast: offset == slides.count - 1,
                                onSkip: finish,
                                onNext: {
                                    if offset == slides.count - 1 {
                                        finish()
                                    } else {
                                        withAnimation { index = offset + 2 } // следующий tag
                                    }
                                }
                            )
                            .tag(offset + 1)
                        }
                    }
                    .tabViewStyle(.page(indexDisplayMode: .never))
                }
                .animation(.easeInOut(duration: 0.25), value: index)
            }
        }
    }

    private func finish() {
        hasOnboarded = true
    }
}

// MARK: - StepProgress (капсулы 3 шт., активная — цвет Accent)
private struct StepProgress: View {
    let current: Int   // 1..total
    let total: Int

    var body: some View {
        HStack(spacing: 16) {
            ForEach(1...total, id: \.self) { step in
                Capsule()
                    .fill(step <= current ? Tokens.Color.accent : Tokens.Color.borderNeutral.opacity(0.25))
                    .frame(height: 6)
                    .overlay(
                        Capsule().stroke(Tokens.Color.borderNeutral.opacity(0.0001), lineWidth: 1)
                    )
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}

// MARK: - Слайд (верх: Skip; середина: иконка; низ: карточный блок с тенью)
private struct SlideScreen: View {
    let slide: OnboardingView.Slide
    let isLast: Bool
    let onSkip: () -> Void
    let onNext: () -> Void

    var body: some View {
        GeometryReader { geo in
            ZStack(alignment: .topTrailing) {
                // Кнопка Skip справа сверху
                Button("Skip") { onSkip() }
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.textSecondary)
                    .padding(.trailing, 20)
                    .padding(.top, 4)
                    .accessibilityIdentifier("onboarding.skip")

                VStack(spacing: 0) {
                    Spacer(minLength: 12)

                    // Иллюстрация: максимум 354pt, иначе 75% ширины
                    let maxSide = min(geo.size.width * 0.75, 354)
                    Image(slide.imageName)
                        .resizable()
                        .scaledToFit()
                        .frame(width: maxSide, height: maxSide)
                        .frame(maxWidth: .infinity, alignment: .center)
                        .padding(.top, 8)

                    Spacer()

                    // Нижний карточный блок — как в макете
                    BottomCard {
                        VStack(spacing: 12) {
                            Text(slide.title)
                                .font(Tokens.Font.h2)
                                .multilineTextAlignment(.center)
                                .foregroundStyle(Tokens.Color.textPrimary)
                                .fixedSize(horizontal: false, vertical: true)

                            Text(slide.subtitle)
                                .font(Tokens.Font.body)
                                .multilineTextAlignment(.center)
                                .foregroundStyle(Tokens.Color.textSecondary)
                                .fixedSize(horizontal: false, vertical: true)
                        }
                        .padding(.horizontal, 20)
                        .padding(.top, 8)

                        PrimaryButton("Continue") {
                            onNext()
                        }
                        .padding(.horizontal, 20)
                        .padding(.top, 16)
                        .padding(.bottom, 8)
                    }
                    .padding(.horizontal, 8) // чтобы тень красиво читалась на краях
                    .padding(.bottom, 8)
                }
            }
            .frame(width: geo.size.width, height: geo.size.height)
        }
        .ignoresSafeArea(.keyboard)
    }
}

// MARK: - Карточный нижний блок (скругление сверху, тень как в макете)
private struct BottomCard<Content: View>: View {
    @ViewBuilder let content: Content

    var body: some View {
        VStack(spacing: 0) {
            content
        }
        .padding(.top, 16)
        .padding(.bottom, 20)
        .background(
            Tokens.Color.surfaceCard,
            in: UnevenRoundedRectangle(
                topLeadingRadius: 28,
                bottomLeadingRadius: 0,
                bottomTrailingRadius: 0,
                topTrailingRadius: 28,
                style: .continuous
            )
        )
        .shadow(color: Tokens.Color.shadowBlack7, radius: 24, y: -2) // соответствует твоему ShadowBlack7 в палитре
        .overlay(
            UnevenRoundedRectangle(
                topLeadingRadius: 28,
                bottomLeadingRadius: 0,
                bottomTrailingRadius: 0,
                topTrailingRadius: 28,
                style: .continuous
            )
            .stroke(Tokens.Color.borderNeutral, lineWidth: 1)
        )
    }
}
