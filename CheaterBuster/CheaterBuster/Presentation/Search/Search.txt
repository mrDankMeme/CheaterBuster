//
//  SearchViewModel.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import Foundation
import Combine
import UIKit

final class SearchViewModel: ObservableObject {

    // MARK: - Input
    @Published var query: String = ""

    // MARK: - Output
    @Published private(set) var results: [ImageHit] = []
    @Published private(set) var isLoading: Bool = false            // мелкие индикаторы (в кнопках)
    @Published private(set) var isBlockingLoading: Bool = false     // full-screen загрузка
    @Published private(set) var errorText: String?

    // MARK: - Deps
    private let search: SearchService
    private let history: HistoryStore
    // settings можно использовать позже (флаги, лимиты, т.п.)
    private let settings: SettingsStore?

    private var bag = Set<AnyCancellable>()

    // MARK: - Init
    init(search: SearchService,
         history: HistoryStore,
         settings: SettingsStore? = nil)
    {
        self.search = search
        self.history = history
        self.settings = settings
        bindQueryDebounce()
    }

    // MARK: - Debounce по вводу (без блокирующей загрузки)
    private func bindQueryDebounce() {
        $query
            .removeDuplicates()
            .debounce(for: .milliseconds(300), scheduler: DispatchQueue.main)
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            .flatMap { [weak self] q -> AnyPublisher<[ImageHit], Never> in
                guard let self, !q.isEmpty else { return Just([]).eraseToAnyPublisher() }
                
                return self.search.searchByName(q)
                    .map { $0 }
                    .catch { [weak self] err -> AnyPublisher<[ImageHit], Never> in
                        self?.errorText = err.localizedDescription
                        return Just([]).eraseToAnyPublisher()
                    }
                    .eraseToAnyPublisher()
            }
            .receive(on: DispatchQueue.main)
            .assign(to: &$results)
    }

    // MARK: - Явный запуск по кнопке «Find»
    func runNameSearch() {
        let q = query.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !q.isEmpty else { return }

        isLoading = true
        isBlockingLoading = true
        errorText = nil

        search.searchByName(q)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                guard let self else { return }
                self.isLoading = false
                self.isBlockingLoading = false
                if case .failure(let err) = completion {
                    self.errorText = err.localizedDescription
                    self.results = []
                }
            } receiveValue: { [weak self] hits in
                guard let self else { return }
                self.results = hits

                
                let previewTitle  = hits.first?.title
                let previewSource = hits.first?.source
                let rec = HistoryRecord(
                    kind: .name,
                    query: q,
                    imageJPEG: nil,
                    titlePreview: previewTitle,
                    sourcePreview: previewSource
                )
                self.history.add(rec)
            }
            .store(in: &bag)
    }

    // MARK: - Запуск по кнопке «Analyze» (по фото)
    func runImageSearch(jpegData: Data) {
        isLoading = true
        isBlockingLoading = true
        errorText = nil

        search.searchByImage(jpegData)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                guard let self else { return }
                self.isLoading = false
                self.isBlockingLoading = false
                if case .failure(let err) = completion {
                    self.errorText = err.localizedDescription
                    self.results = []
                }
            } receiveValue: { [weak self] hits in
                guard let self else { return }
                self.results = hits

                
                let thumbData = (UIImage(data: jpegData)?
                    .jpegData(compressionQuality: 0.5)) ?? jpegData

                let rec = HistoryRecord(
                    kind: .face,
                    query: nil,
                    imageJPEG: thumbData,
                    titlePreview: hits.first?.title,
                    sourcePreview: hits.first?.source
                )
                self.history.add(rec)
            }
            .store(in: &bag)
    }

    // MARK: - Прочее (если нужно использовать)
    func resetResults() {
        results = []
        errorText = nil
    }
}
//
//  FaceSearchView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 11/01/25.
//

import SwiftUI
import PhotosUI
import Swinject
import UIKit

struct FaceSearchView: View {
    @ObservedObject var vm: SearchViewModel
    @Environment(\.dismiss) private var dismiss
    @Environment(\.resolver) private var resolver

    @State private var item: PhotosPickerItem?
    @State private var image: UIImage?

    // Поворот/масштаб
    @State private var rotationAngle: Angle = .zero              // кратно 90°
    @State private var userZoom: CGFloat = 1.0                   // ручной zoom (resize кнопка)

    @State private var didAnalyze = false
    @State private var showPaywall = false

    let onFinished: () -> Void

    init(vm: SearchViewModel, onFinished: @escaping () -> Void) {
        self.vm = vm
        self.onFinished = onFinished
    }

    var body: some View {
        ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            VStack(spacing: 0) {
                // MARK: Header — как в Cheater
                HStack {
                    Button { dismiss() } label: {
                        ZStack {
                            Circle()
                                .fill(.white)
                                .frame(width: 44.scale, height: 44.scale)
                                .shadow(color: Tokens.Color.shadowBlack7, radius: 9.scale, x: 0, y: 0)

                            Image("backArrow")
                                .resizable()
                                .renderingMode(.template)
                                .scaledToFit()
                                .frame(width: 20.scale, height: 20.scale)
                                .foregroundStyle(Color(hex: "#141414"))
                        }
                    }
                    .buttonStyle(.plain)

                    Spacer()

                    Text("Face search")
                        .font(.system(size: 18.scale, weight: .medium))
                        .foregroundStyle(Color(hex: "#141414"))

                    Spacer()
                    Color.clear.frame(width: 44.scale, height: 44.scale)
                }
                .padding(.horizontal, 16.scale)
                .padding(.top, 16.scale)

                // MARK: Preview — всегда AspectFit с учётом поворота
                GeometryReader { geo in
                    ZStack {
                        if let uiImage = image {
                            let fitScale = computeFitScale(
                                image: uiImage,
                                container: geo.size,
                                angle: rotationAngle
                            )
                            Image(uiImage: uiImage)
                                .resizable()
                                .scaledToFit() // базовое aspectFit
                                .rotationEffect(rotationAngle)
                                .scaleEffect(fitScale * userZoom) // подгон + пользовательский zoom
                                .frame(width: geo.size.width, height: geo.size.height)
                                .clipped()
                                .animation(.easeInOut(duration: 0.22), value: rotationAngle)
                                .animation(.easeInOut(duration: 0.22), value: userZoom)
                        } else {
                            ContentUnavailableView(
                                "Select a photo",
                                systemImage: "photo",
                                description: Text("Pick one image to search by face.")
                            )
                        }
                    }
                }

                // MARK: Bottom controls
                HStack(spacing: 16.scale) {
                    // Центрированный блок из трёх кнопок
                    HStack(spacing: 16.scale) {
                        ControlButton(asset: "rotateLeft") {
                            withAnimation { rotationAngle -= .degrees(90) }
                        }
                        ControlButton(asset: "rotateRight") {
                            withAnimation { rotationAngle += .degrees(90) }
                        }
                        ControlButton(asset: "resize") {
                            withAnimation { userZoom = (abs(userZoom - 1.0) < 0.001) ? 1.2 : 1.0 }
                        }
                    }
                    .frame(maxWidth: .infinity) // ✅ строго по центру

                    // Next — справа
                    Button {
                        guard let img = image,
                              let jpeg = img.jpegData(compressionQuality: 0.85) else { return }

                        let isPremium = (resolver.resolve(PremiumStore.self)?.isPremium ?? false)
                        guard isPremium else { showPaywall = true; return }

                        didAnalyze = true
                        vm.runImageSearch(jpegData: jpeg)
                    } label: {
                        ZStack {
                            Circle()
                                .fill(Tokens.Color.accent) // ✅ accent
                                .frame(width: 48.scale, height: 48.scale)
                                .shadow(color: Tokens.Color.shadowBlack7, radius: 9.scale, x: 0, y: 0)

                            Image("nextArrow")
                                .resizable()
                                .renderingMode(.template)
                                .scaledToFit()
                                .frame(width: 20.scale, height: 20.scale) // ✅ 20×20
                                .foregroundStyle(.white)
                        }
                    }
                    .buttonStyle(.plain)
                    .disabled(image == nil || vm.isLoading)
                }
                .padding(.horizontal, 24.scale)
                .padding(.vertical, 20.scale)
                .background(
                    Tokens.Color.surfaceCard,
                    ignoresSafeAreaEdges: .bottom
                )
            }
        }
        .navigationBarBackButtonHidden(true)

        // Photos picker
        .photosPicker(isPresented: Binding(get: { image == nil && item == nil }, set: { _ in }),
                      selection: $item, matching: .images)
        .onChange(of: item) { _, newValue in
            Task { @MainActor in
                guard let data = try? await newValue?.loadTransferable(type: Data.self),
                      let img = UIImage(data: data) else { return }
                image = img
                rotationAngle = .zero
                userZoom = 1.0
            }
        }

        // Завершение анализа → пушим результаты
        .onChange(of: vm.isLoading) { was, isNow in
            if didAnalyze && was == true && isNow == false {
                didAnalyze = false
                onFinished()
            }
        }

        // Full-screen loading
        .fullScreenCover(isPresented: Binding(get: { vm.isBlockingLoading }, set: { _ in })) {
            LoadingView(mode: .face, previewImage: image, cancelAction: nil)
                .interactiveDismissDisabled(true)
        }

        // Paywall
        .fullScreenCover(isPresented: $showPaywall) {
            let paywallVM = resolver.resolve(PaywallViewModel.self)!
            PaywallView(vm: paywallVM).presentationDetents([.large])
        }
    }

    /// Расчёт масштабирования для идеального AspectFit при 0°/90°/180°/270°
    private func computeFitScale(image: UIImage, container: CGSize, angle: Angle) -> CGFloat {
        // нормализуем угол к [0,360)
        let deg = abs(Int(angle.degrees)) % 360
        let swap = (deg == 90 || deg == 270)

        // реальный размер картинки в поинтах
        let iw = image.size.width
        let ih = image.size.height

        // при 90/270 меняются местами оси
        let targetW = swap ? ih : iw
        let targetH = swap ? iw : ih

        let sx = container.width  / targetW
        let sy = container.height / targetH
        return min(sx, sy)
    }
}

// MARK: - Универсальная кружковая кнопка 48×48 с тенью и иконкой 20×20
private struct ControlButton: View {
    let asset: String
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            ZStack {
                Circle()
                    .fill(Color.white)
                    .frame(width: 48.scale, height: 48.scale)
                    .shadow(color: Tokens.Color.shadowBlack7, radius: 9.scale, x: 0, y: 0)

                Image(asset)
                    .resizable()
                    .renderingMode(.template)
                    .scaledToFit()
                    .frame(width: 20.scale, height: 20.scale)
                    .foregroundStyle(Color(hex: "#141414"))
            }
        }
        .buttonStyle(.plain)
    }
}
//
//  SearchScreen.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import SwiftUI
import Swinject

struct SearchScreen: View {
    @State private var goPhoto = false
    @State private var goResults = false

    private let vm: SearchViewModel
    init(vm: SearchViewModel) { self.vm = vm }

    var body: some View {
        NavigationStack {
            VStack(alignment: .leading, spacing: 24.scale) {
                Text("Find your partner")
                    .font(.system(size: 28.scale, weight: .medium))
                    .foregroundStyle(Color(hex: "#141414"))
                    .padding(.top, Tokens.Spacing.x8.scale)

                Button { goPhoto = true } label: {
                    VStack(spacing: 16.scale) {
                        Image("faceSearchIcon")
                            .renderingMode(.original)
                            .resizable()
                            .scaledToFit()
                            .frame(width: 40.scale, height: 40.scale)

                        Text("Finding a partner by face")
                            .font(.system(size: 16.scale, weight: .regular))
                            .foregroundStyle(Color(hex: "#141414"))
                    }
                    .frame(maxWidth: .infinity, minHeight: 160.scale)
                    .background(
                        RoundedRectangle(cornerRadius: 22.scale, style: .continuous)
                            .fill(Color.white)
                    )
                    .shadow(color: Color(hex: "#ACACAC").opacity(0.1),
                            radius: 9.scale, y: 2.scale)
                }
                .buttonStyle(.plain)

                Spacer()
            }
            .padding(.horizontal, Tokens.Spacing.x16.scale)
            .background(Tokens.Color.backgroundMain.ignoresSafeArea())

            .navigationDestination(isPresented: $goPhoto) {
                FaceSearchView(vm: vm, onFinished: { goResults = true })
                    .navigationBarBackButtonHidden(true)
            }
            .navigationDestination(isPresented: $goResults) {
                SearchResultsView(results: vm.results, mode: .face)
                    .navigationBarBackButtonHidden(true)
            }
        }
    }
}
//
//  NameSearchView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/29/25.
//

import SwiftUI
import Swinject // MARK: - Added

struct NameSearchView: View {
    @ObservedObject var vm: SearchViewModel
    @Environment(\.dismiss) private var dismiss
    @Environment(\.resolver) private var resolver // MARK: - Added

    @State private var goResults = false
    @State private var didSubmit = false
    @State private var showPaywall = false // MARK: - Added

    var body: some View {
        ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            VStack(alignment: .leading, spacing: Tokens.Spacing.x16) {
                // Header
                HStack {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "arrow.left")
                            .font(.system(size: 16, weight: .semibold))
                            .foregroundStyle(Tokens.Color.textPrimary)
                            .padding(12)
                            .background(
                                Tokens.Color.surfaceCard,
                                in: RoundedRectangle(cornerRadius: 16, style: .continuous)
                            )
                            .apply(Tokens.Shadow.card)
                    }

                    Spacer()

                    Text("Name search")
                        .font(Tokens.Font.title)
                        .foregroundStyle(Tokens.Color.textPrimary)

                    Spacer().frame(width: 44) // симметрия
                }
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.top, Tokens.Spacing.x16)

                // Search field
                VStack(spacing: Tokens.Spacing.x16) {
                    SearchField("Partner's name...", text: $vm.query)
                        .padding(.horizontal, Tokens.Spacing.x16)

                    Spacer(minLength: Tokens.Spacing.x16)
                }
            }
        }
        .navigationBarBackButtonHidden(true)
        .navigationBarTitleDisplayMode(.inline)

        // Нижняя большая кнопка Find
        .safeAreaInset(edge: .bottom) {
            HStack {
                PrimaryButton(
                    "Find",
                    isLoading: vm.isLoading,
                    isDisabled: vm.query.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty || vm.isLoading
                ) {
                    // MARK: - Added (premium gate)
                    let isPremium = (resolver.resolve(PremiumStore.self)?.isPremium ?? false)
                    guard isPremium else {
                        showPaywall = true
                        return
                    }
                    didSubmit = true
                    vm.runNameSearch()
                }
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.vertical, Tokens.Spacing.x16)
            .background(
                Tokens.Color.backgroundMain,
                ignoresSafeAreaEdges: .bottom
            )
        }

        // Переход к результатам после завершения загрузки
        .onChange(of: vm.isLoading) { was, isNow in
            if didSubmit && was == true && isNow == false {
                didSubmit = false
                goResults = true
            }
        }
        .navigationDestination(isPresented: $goResults) {
            SearchResultsView(results: vm.results, mode: .name)
        }

        // Блокирующая "загрузка"
        .fullScreenCover(
            isPresented: Binding(
                get: { vm.isBlockingLoading },
                set: { _ in }
            )
        ) {
            LoadingView(mode: .name, previewImage: nil, cancelAction: nil)
                .interactiveDismissDisabled(true)
        }

        // MARK: - Added Paywall
        .fullScreenCover(isPresented: $showPaywall) {
            let paywallVM = resolver.resolve(PaywallViewModel.self)!
            PaywallView(vm: paywallVM)
                .presentationDetents([.large])
        }
    }
}
//
//  SearchResultsView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//


import SwiftUI

struct SearchResultsView: View {
    enum Mode { case face, name }

    let results: [ImageHit]
    let mode: Mode

    private let columns = [
        GridItem(.flexible(), spacing: Tokens.Spacing.x16),
        GridItem(.flexible(), spacing: Tokens.Spacing.x16)
    ]

    @Namespace private var ns

    var body: some View {
        ScrollView {
            if results.isEmpty {
                ContentUnavailableView(
                    "No results found",
                    systemImage: "magnifyingglass.circle",
                    description: Text("No matches found. Please try a different photo or name.")
                )
                .padding(.top, Tokens.Spacing.x24)
            } else {
                LazyVGrid(columns: columns, spacing: Tokens.Spacing.x16) {
                    ForEach(results) { hit in
                        if mode == .face {
                            FaceResultCard(hit: hit)
                        } else {
                            NameResultCard(hit: hit)
                        }
                    }
                }
                .padding(.horizontal, Tokens.Spacing.x16)
                .padding(.vertical, Tokens.Spacing.x24)
                .animation(.easeInOut(duration: 0.25), value: results)
            }
        }
        .background(Tokens.Color.backgroundMain.ignoresSafeArea())
        .navigationTitle(mode == .face ? "Face results" : "Name results")
        .navigationBarTitleDisplayMode(.inline)
    }
}

// MARK: - Cards

private struct FaceResultCard: View {
    let hit: ImageHit

    var body: some View {
        VStack(spacing: Tokens.Spacing.x8) {
            AsyncThumb(url: hit.thumbnailURL)
                .frame(height: 160)
                .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            Tokens.Color.surfaceCard,
            in: RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
        )
        .apply(Tokens.Shadow.card)
    }
}

private struct NameResultCard: View {
    let hit: ImageHit

    var body: some View {
        VStack(alignment: .leading, spacing: Tokens.Spacing.x8) {
            AsyncThumb(url: hit.thumbnailURL)
                .frame(height: 160)
                .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))

            VStack(alignment: .leading, spacing: 2) {
                Text(hit.title)
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.textPrimary)
                    .lineLimit(1)
                Text(hit.source)
                    .font(Tokens.Font.captionRegular)
                    .foregroundStyle(Tokens.Color.textSecondary)
                    .lineLimit(1)
            }

            if let url = hit.linkURL {
                Link(destination: url) {
                    HStack(spacing: 4) {
                        Text("Open")
                        Image(systemName: "arrow.up.right.square")
                    }
                    .font(Tokens.Font.caption)
                    .foregroundStyle(Tokens.Color.accent)
                }
                .padding(.top, Tokens.Spacing.x4)
            }
        }
        .padding(Tokens.Spacing.x12)
        .background(
            Tokens.Color.surfaceCard,
            in: RoundedRectangle(cornerRadius: Tokens.Radius.medium, style: .continuous)
        )
        .apply(Tokens.Shadow.card)
    }
}

private struct AsyncThumb: View {
    let url: URL?
    var body: some View {
        AsyncImage(url: url) { phase in
            switch phase {
            case .empty:
                ZStack { Color.gray.opacity(0.1); ProgressView() }
            case .success(let image):
                image.resizable().scaledToFill().clipped()
            case .failure:
                ZStack {
                    Color.gray.opacity(0.2)
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundStyle(.gray)
                }
            @unknown default:
                EmptyView()
            }
        }
    }
}
